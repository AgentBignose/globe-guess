<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Globe Guess</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    body { margin: 0; overscroll-behavior: none; }
    * { -webkit-tap-highlight-color: transparent; }
    @keyframes pop {
      0% { transform: scale(.96); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .pop { animation: pop .18s ease-out; }
    @keyframes confettiFall {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
      15% { opacity: 1; }
      100% { transform: translateY(520px) rotate(320deg); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="root" class="h-full"></div>

  <!-- Difficulty mapping (local file) -->
  <script src="./difficulty-map.js"></script>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Three + Globe.gl -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/globe.gl@2.45.0/dist/globe.gl.min.js"></script>

  <!-- TopoJSON -->
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // -------------------------
    // i18n
    // -------------------------
    const I18N = {
      en: {
        title: "Globe Guess",
        subtitle: "Two modes: click the named country, or pick the right name from 8 options.",
        round: "Round",
        score: "Score",
        streak: "Streak",
        accuracy: "Accuracy",
        mode: "Mode",
        clickMode: "Click",
        choiceMode: "Choice",
        newGame: "New Game",
        settings: "Settings",
        close: "Close",
        save: "Save",
        language: "Language",
        english: "English",
        german: "German",
        theme: "Theme",
        dark: "Dark",
        light: "Light",
        borders: "Borders",
        borderIntensity: "Border intensity",
        roundsPerGame: "Rounds per game",
        timer: "Timer",
        timerEnabled: "Enable timer",
        secondsPerRound: "Seconds per round",
        difficulty: "Difficulty",
        maxDifficulty: "Max difficulty",
        difficultyHint: "Limits the hardest countries in your pool (1..5).",
        next: "Next",
        yourAnswer: "Your answer",
        correctAnswer: "Correct answer",
        distance: "Distance",
        points: "Points",
        findAndClick: "Find and click:",
        clickAnywhere: "Click anywhere on the globe. Score is based on distance to the border.",
        highlightedIs: "The highlighted country is:",
        highlightHint: "(It flies to center + zoom depends on size)",
        loading: "Loading globe‚Ä¶",
        loadFailTitle: "Couldn‚Äôt load data",
        loadFailTip: "Make sure you host these locally: ./data/countries-110m.json and ./data/country-names.tsv",
        correct: "Correct!",
        wrong: "Wrong",
        gameOverTitle: "Game Over",
        gameOverBody: "Nice run! Here are your stats.",
        playAgain: "Play again",
        summaryMode: "Mode",
        summaryRounds: "Rounds",
        summaryCorrect: "Correct",
        summaryWrong: "Wrong",
        highscore: "Highscores",
        reset: "Reset",
        howTo: "How it works",
        howClick: "Click Mode: you‚Äôre told a country name; click/tap on the globe.",
        howChoice: "Choice Mode: the correct country is raised/green; pick its name from 8 options.",
        howDrag: "Drag to rotate, pinch/scroll to zoom.",
        pointsRuleClick: "Click: inside=10, outside=max(0,10-floor(distance_km/100))",
        pointsRuleChoice: "Choice: correct=100 + 15*(streak-1), wrong=-25",
        difficultyMult: "Difficulty multiplier",
        revealTitle: "Answer",
        proceed: "Continue",
        difficultyClimax: "Difficulty climax",
        difficultyClimaxHint: "Easier early rounds, harder later rounds."
      },
      de: {
        title: "Globus-Quiz",
        subtitle: "Zwei Modi: Klicke das genannte Land oder w√§hle den richtigen Namen aus 8 Optionen.",
        round: "Runde",
        score: "Punkte",
        streak: "Serie",
        accuracy: "Trefferquote",
        mode: "Modus",
        clickMode: "Klick",
        choiceMode: "Auswahl",
        newGame: "Neues Spiel",
        settings: "Einstellungen",
        close: "Schlie√üen",
        save: "Speichern",
        language: "Sprache",
        english: "Englisch",
        german: "Deutsch",
        theme: "Theme",
        dark: "Dunkel",
        light: "Hell",
        borders: "Grenzen",
        borderIntensity: "Grenz-Intensit√§t",
        roundsPerGame: "Runden pro Spiel",
        timer: "Timer",
        timerEnabled: "Timer aktivieren",
        secondsPerRound: "Sekunden pro Runde",
        difficulty: "Schwierigkeit",
        maxDifficulty: "Max. Schwierigkeit",
        difficultyHint: "Begrenzt die schwierigsten L√§nder im Pool (1..5).",
        next: "Weiter",
        yourAnswer: "Deine Antwort",
        correctAnswer: "Richtige Antwort",
        distance: "Distanz",
        points: "Punkte",
        findAndClick: "Finde und klicke:",
        clickAnywhere: "Klicke irgendwo auf den Globus. Die Punkte h√§ngen von der Distanz zur Grenze ab.",
        highlightedIs: "Das markierte Land ist:",
        highlightHint: "(Fliegt ins Zentrum + Zoom je nach Gr√∂√üe)",
        loading: "Globus wird geladen‚Ä¶",
        loadFailTitle: "Daten konnten nicht geladen werden",
        loadFailTip: "Bitte lokal hosten: ./data/countries-110m.json und ./data/country-names.tsv",
        correct: "Richtig!",
        wrong: "Falsch",
        gameOverTitle: "Spiel vorbei",
        gameOverBody: "Gut gemacht! Hier sind deine Statistiken.",
        playAgain: "Nochmal spielen",
        summaryMode: "Modus",
        summaryRounds: "Runden",
        summaryCorrect: "Richtig",
        summaryWrong: "Falsch",
        highscore: "Highscores",
        reset: "Reset",
        howTo: "So funktioniert‚Äôs",
        howClick: "Klick-Modus: Du bekommst einen L√§ndernamen und klickst/tippst auf den Globus.",
        howChoice: "Auswahl-Modus: Das richtige Land ist erh√∂ht/gr√ºn; w√§hle den Namen aus 8 Optionen.",
        howDrag: "Ziehen zum Drehen, Pinch/Scroll zum Zoomen.",
        pointsRuleClick: "Klick: innen=10, au√üen=max(0,10-floor(distanz_km/100))",
        pointsRuleChoice: "Auswahl: richtig=100 + 15*(serie-1), falsch=-25",
        difficultyMult: "Schwierigkeits-Multiplikator",
        revealTitle: "Antwort",
        proceed: "Weiter",
        difficultyClimax: "Schwierigkeits-Klimax",
        difficultyClimaxHint: "Leicht am Anfang, sp√§ter schwieriger."
      }
    };

    // -------------------------
    // utils
    // -------------------------
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const rad = (d) => d * Math.PI / 180;
    const deg = (r) => r * 180 / Math.PI;

    function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function formatPct(x) { if (!isFinite(x)) return "‚Äî"; return `${Math.round(x * 100)}%`; }

    // -------------------------
    // localStorage safe + settings migration
    // -------------------------
    const DEFAULT_SETTINGS = {
      lang: "en",
      theme: "dark",
      borderIntensity: 0.8,
      roundsTotal: 10,
      timerEnabled: false,
      secondsPerRound: 20,
      maxDifficulty: 5.0
    };

    function safeLSGet(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        return raw == null ? fallback : JSON.parse(raw);
      } catch { return fallback; }
    }
    function safeLSSet(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }

    function normalizeSettings(maybe) {
      const s = { ...DEFAULT_SETTINGS, ...(maybe && typeof maybe === "object" ? maybe : {}) };

      s.lang = (s.lang === "de" || s.lang === "en") ? s.lang : DEFAULT_SETTINGS.lang;
      s.theme = (s.theme === "light" || s.theme === "dark") ? s.theme : DEFAULT_SETTINGS.theme;

      s.borderIntensity = clamp(Number(s.borderIntensity ?? DEFAULT_SETTINGS.borderIntensity), 0, 1);
      s.roundsTotal = clamp(parseInt(s.roundsTotal ?? DEFAULT_SETTINGS.roundsTotal, 10), 5, 25);

      s.timerEnabled = !!s.timerEnabled;
      s.secondsPerRound = clamp(parseInt(s.secondsPerRound ?? DEFAULT_SETTINGS.secondsPerRound, 10), 5, 120);

      s.maxDifficulty = clamp(Number(s.maxDifficulty ?? DEFAULT_SETTINGS.maxDifficulty), 1, 5);

      return s;
    }

    // -------------------------
    // geometry / stats helpers
    // -------------------------
    function normLonNear(lon, refLon) {
      let x = lon;
      while (x - refLon > 180) x -= 360;
      while (x - refLon < -180) x += 360;
      return x;
    }
    function projectEquirect(lon, lat, lat0Deg, refLonDeg) {
      const lat0 = rad(lat0Deg);
      const lonN = normLonNear(lon, refLonDeg);
      const x = rad(lonN - refLonDeg) * Math.cos(lat0);
      const y = rad(lat - lat0Deg);
      return { x, y };
    }
    function pointInRingProjected(px, py, ringXY) {
      let inside = false;
      for (let i = 0, j = ringXY.length - 1; i < ringXY.length; j = i++) {
        const xi = ringXY[i].x, yi = ringXY[i].y;
        const xj = ringXY[j].x, yj = ringXY[j].y;
        const intersect = ((yi > py) !== (yj > py)) &&
          (px < (xj - xi) * (py - yi) / (yj - yi + 1e-18) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function distPointToSegment(px, py, ax, ay, bx, by) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const ab2 = abx*abx + aby*aby;
      let t = ab2 > 0 ? (apx*abx + apy*aby) / ab2 : 0;
      t = clamp(t, 0, 1);
      const cx = ax + t * abx;
      const cy = ay + t * aby;
      const dx = px - cx, dy = py - cy;
      return Math.sqrt(dx*dx + dy*dy);
    }

    // Distance to border (km) + inside check
    function polygonDistanceKmToBorder(pointLon, pointLat, feature) {
      const lat0 = pointLat;
      const refLon = pointLon;
      const geom = feature.geometry;
      if (!geom) return { inside: false, distKm: 1e9 };

      const polys = [];
      if (geom.type === "Polygon") polys.push(geom.coordinates);
      else if (geom.type === "MultiPolygon") for (const p of geom.coordinates) polys.push(p);
      else return { inside: false, distKm: 1e9 };

      const p = projectEquirect(pointLon, pointLat, lat0, refLon);
      const px = p.x, py = p.y;

      let inside = false;
      let minDistRad = Infinity;

      for (const poly of polys) {
        if (!poly || !poly.length) continue;
        const outer = poly[0];
        if (!outer || outer.length < 3) continue;

        const outerXY = outer.map(([lon, lat]) => projectEquirect(lon, lat, lat0, refLon));
        const inOuter = pointInRingProjected(px, py, outerXY);

        let inHole = false;
        for (let h = 1; h < poly.length; h++) {
          const hole = poly[h];
          if (!hole || hole.length < 3) continue;
          const holeXY = hole.map(([lon, lat]) => projectEquirect(lon, lat, lat0, refLon));
          if (pointInRingProjected(px, py, holeXY)) { inHole = true; break; }
        }

        if (inOuter && !inHole) inside = true;

        const ringsToMeasure = [outer, ...poly.slice(1)];
        for (const ring of ringsToMeasure) {
          if (!ring || ring.length < 2) continue;
          const ringXY = ring.map(([lon, lat]) => projectEquirect(lon, lat, lat0, refLon));
          for (let i = 0; i < ringXY.length - 1; i++) {
            const a = ringXY[i], b = ringXY[i + 1];
            const d = distPointToSegment(px, py, a.x, a.y, b.x, b.y);
            if (d < minDistRad) minDistRad = d;
          }
        }
      }

      const EARTH_R = 6371;
      const distKm = isFinite(minDistRad) ? (minDistRad * EARTH_R) : 1e9;
      return { inside, distKm };
    }

    // Feature stats for fly-to + complexity
    function featureStats(feature) {
      const geom = feature?.geometry;
      if (!geom) return null;

      const points = [];
      const pushRing = (ring) => {
        for (const [lon, lat] of ring) {
          if (isFinite(lon) && isFinite(lat)) points.push([lon, lat]);
        }
      };

      let parts = 1;
      let vertices = 0;

      if (geom.type === "Polygon") {
        parts = 1;
        for (const ring of geom.coordinates) {
          vertices += (ring?.length || 0);
          pushRing(ring);
        }
      } else if (geom.type === "MultiPolygon") {
        parts = geom.coordinates.length || 1;
        for (const poly of geom.coordinates) {
          for (const ring of poly) {
            vertices += (ring?.length || 0);
            pushRing(ring);
          }
        }
      } else return null;

      if (!points.length) return null;

      let lon0 = points[0][0];
      let sumLon = 0, sumLat = 0;
      let minLat =  90, maxLat = -90;
      let minLonU =  1e9, maxLonU = -1e9;

      for (const [lonRaw, lat] of points) {
        let lon = lonRaw;
        while (lon - lon0 > 180) lon -= 360;
        while (lon - lon0 < -180) lon += 360;

        sumLon += lon;
        sumLat += lat;

        minLat = Math.min(minLat, lat);
        maxLat = Math.max(maxLat, lat);
        minLonU = Math.min(minLonU, lon);
        maxLonU = Math.max(maxLonU, lon);
      }

      let lng = sumLon / points.length;
      let lat = sumLat / points.length;
      while (lng > 180) lng -= 360;
      while (lng < -180) lng += 360;

      const latSpan = Math.max(0.1, maxLat - minLat);
      const lonSpan = Math.max(0.1, maxLonU - minLonU);
      const effLonSpan = lonSpan * Math.cos(rad(lat));
      const span = Math.max(latSpan, effLonSpan);

      return { lat, lng, span, parts, vertices };
    }

    function altitudeFromSpan(spanDeg) {
      const s = clamp(spanDeg, 0.8, 140);
      const alt = 0.95 + (s / 60) * 1.25;
      return clamp(alt, 1.05, 2.8);
    }

    // -------------------------
    // Difficulty computation
    // -------------------------
    function bigramSet(s) {
      const t = (s || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
      const a = [];
      for (let i = 0; i < t.length - 1; i++) a.push(t.slice(i, i + 2));
      return new Set(a);
    }
    function jaccard(a, b) {
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      const union = a.size + b.size - inter;
      return union ? inter / union : 0;
    }
    function haversineKm(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = rad(lat2 - lat1);
      const dLon = rad(lon2 - lon1);
      const s1 = Math.sin(dLat / 2);
      const s2 = Math.sin(dLon / 2);
      const a = s1*s1 + Math.cos(rad(lat1))*Math.cos(rad(lat2))*s2*s2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function computeDifficultyForCountries(countries, idToName) {
      const D = window.DIFFICULTY_MAP;
      const weights = D?.WEIGHTS ?? { familiarity: .4, geo: .3, region: .2, name: .1 };

      // Precompute stats
      const statsById = new Map();
      for (const f of countries) statsById.set(String(f.id), featureStats(f));

      // GEO complexity proxy: small span, many parts, many vertices => harder
      // We'll normalize by observed distributions.
      const spans = [];
      const parts = [];
      const verts = [];
      const ids = countries.map(f => String(f.id));

      for (const id of ids) {
        const st = statsById.get(id);
        if (!st) continue;
        spans.push(st.span);
        parts.push(st.parts);
        verts.push(st.vertices);
      }

      const minSpan = Math.min(...spans), maxSpan = Math.max(...spans);
      const minParts = Math.min(...parts), maxParts = Math.max(...parts);
      const minVerts = Math.min(...verts), maxVerts = Math.max(...verts);

      const norm01 = (v, a, b) => {
        if (!isFinite(v)) return 0.5;
        if (b <= a) return 0.5;
        return clamp((v - a) / (b - a), 0, 1);
      };

      // Regional ambiguity: average distance to 5 nearest centroids (smaller distance => harder)
      const centroid = ids.map(id => {
        const st = statsById.get(id);
        return st ? { id, lat: st.lat, lng: st.lng } : null;
      }).filter(Boolean);

      const neighborAvgDist = new Map();
      const distsAll = [];

      for (const a of centroid) {
        const dists = [];
        for (const b of centroid) {
          if (a.id === b.id) continue;
          dists.push(haversineKm(a.lat, a.lng, b.lat, b.lng));
        }
        dists.sort((x,y)=>x-y);
        const k = dists.slice(0, 5);
        const avg = k.reduce((s,v)=>s+v,0) / Math.max(1, k.length);
        neighborAvgDist.set(a.id, avg);
        distsAll.push(avg);
      }
      const minN = Math.min(...distsAll), maxN = Math.max(...distsAll);

      // Name ambiguity: confusable groups + similarity to other names
      const nameBigrams = new Map();
      const names = ids.map(id => (idToName.get(id) || "").trim());
      for (let i = 0; i < ids.length; i++) nameBigrams.set(ids[i], bigramSet(names[i] || ""));

      const nameAmb = new Map();
      for (let i = 0; i < ids.length; i++) {
        const idA = ids[i];
        const nameA = idToName.get(idA) || "";
        let best = 0;
        const setA = nameBigrams.get(idA);
        for (let j = 0; j < ids.length; j++) {
          if (i === j) continue;
          const idB = ids[j];
          const setB = nameBigrams.get(idB);
          best = Math.max(best, jaccard(setA, setB));
        }
        const boost = D?.nameAmbiguityBoost ? D.nameAmbiguityBoost(nameA) : 0;
        // similarity is weak signal; boost is strong signal
        nameAmb.set(idA, clamp(0.55*boost + 0.45*best, 0, 1));
      }

      // Combine
      const diffById = new Map();
      for (const id of ids) {
        const st = statsById.get(id);
        const name = idToName.get(id) || "";

        const familiarity = D?.familiarityScore ? D.familiarityScore(name) : 0.45;

        // geo complexity: small span is hard => invert span norm
        const spanN = st ? norm01(st.span, minSpan, maxSpan) : 0.5;
        const invSpan = 1 - spanN;
        const partsN = st ? norm01(st.parts, minParts, maxParts) : 0.0;
        const vertsN = st ? norm01(st.vertices, minVerts, maxVerts) : 0.5;

        let geo = clamp(0.55*invSpan + 0.25*partsN + 0.20*vertsN, 0, 1);

        // region ambiguity: smaller neighbor distance => harder => invert
        const nAvg = neighborAvgDist.get(id);
        const nNorm = norm01(nAvg, minN, maxN);
        const region = clamp(1 - nNorm, 0, 1);

        const nameA = nameAmb.get(id) ?? 0;

        // Apply optional overrides by country name
        const o = (D?.OVERRIDES && name && D.OVERRIDES[name]) ? D.OVERRIDES[name] : null;
        const fam2 = o?.familiarity != null ? clamp(o.familiarity,0,1) : familiarity;
        const geo2 = o?.geo != null ? clamp(o.geo,0,1) : geo;
        const reg2 = o?.region != null ? clamp(o.region,0,1) : region;
        const nam2 = o?.name != null ? clamp(o.name,0,1) : nameA;

        const mix =
          weights.familiarity * fam2 +
          weights.geo         * geo2 +
          weights.region      * reg2 +
          weights.name        * nam2;

        // map 0..1 -> 1..5
        const difficulty = clamp(1 + 4 * mix, 1, 5);
        diffById.set(id, {
          familiarity: fam2,
          geo: geo2,
          region: reg2,
          name: nam2,
          mix,
          difficulty
        });
      }

      return { diffById, statsById };
    }

    function diffStars(diff) {
      const full = clamp(Math.round(diff), 1, 5);
      return "‚òÖ".repeat(full) + "‚òÜ".repeat(5 - full);
    }

    // multiplier used for points
    // 1..5 => 0.85..1.25
    function difficultyMultiplier(diff) {
      const t = (clamp(diff, 1, 5) - 1) / 4;
      return 0.85 + 0.40 * t;
    }

    // -------------------------
    // scoring
    // -------------------------
    function baseScoreClick(inside, distKm) {
      if (inside) return { base: 10, distKm: 0 };
      const bins = Math.floor(distKm / 100);
      const base = Math.max(0, 10 - bins);
      return { base, distKm };
    }
    function baseScoreChoice({ correct, newStreak }) {
      if (correct) return 100 + 15 * (newStreak - 1);
      return -25;
    }

    // -------------------------
    // UI components
    // -------------------------
    function SettingsModal({ open, t, themeTokens, settings, setSettings, onClose }) {
      const [draft, setDraft] = useState(settings);

      useEffect(() => { setDraft(settings); }, [open]);

      if (!open) return null;

      const d = normalizeSettings(draft);

      const setD = (patch) => setDraft(prev => normalizeSettings({ ...normalizeSettings(prev), ...patch }));

      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" onClick={onClose}></div>
          <div className="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3 sm:p-6">
            <div className={["w-full sm:max-w-lg rounded-2xl ring-1 p-4 sm:p-5 pop", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className="flex items-start justify-between gap-3">
                <div>
                  <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{t("settings")}</div>
                  <div className={["text-sm mt-1", themeTokens.textMuted].join(" ")}>{t("subtitle")}</div>
                </div>
                <button onClick={onClose} className={["rounded-xl px-3 py-2 ring-1 transition", themeTokens.btnGhost].join(" ")}>
                  {t("close")}
                </button>
              </div>

              <div className="mt-4 grid gap-3">
                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("language")}</div>
                  <div className="mt-2 flex gap-2">
                    <button onClick={() => setD({ lang: "en" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.lang === "en" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("english")}
                    </button>
                    <button onClick={() => setD({ lang: "de" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.lang === "de" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("german")}
                    </button>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("theme")}</div>
                  <div className="mt-2 flex gap-2">
                    <button onClick={() => setD({ theme: "dark" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.theme === "dark" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("dark")}
                    </button>
                    <button onClick={() => setD({ theme: "light" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.theme === "light" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("light")}
                    </button>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("borders")}</div>
                  <div className="mt-2 flex items-center gap-2">
                    <input type="range" min="0" max="100"
                      value={Math.round(d.borderIntensity * 100)}
                      onChange={(e) => setD({ borderIntensity: clamp(parseInt(e.target.value, 10) / 100, 0, 1) })}
                      className="w-full" />
                    <div className={["w-12 text-right text-sm font-semibold", themeTokens.textStrong].join(" ")}>
                      {Math.round(d.borderIntensity * 100)}%
                    </div>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("maxDifficulty")}</div>
                      <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>{t("difficultyHint")}</div>
                    </div>
                    <div className={["text-lg font-semibold", themeTokens.textStrong].join(" ")}>
                      {Number(d.maxDifficulty).toFixed(1)}
                    </div>
                  </div>
                  <div className="mt-2">
                    <input type="range" min="1" max="5" step="0.1"
                      value={d.maxDifficulty}
                      onChange={(e) => setD({ maxDifficulty: clamp(parseFloat(e.target.value), 1, 5) })}
                      className="w-full" />
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("roundsPerGame")}</div>
                  <div className="mt-2 flex items-center gap-2">
                    <input type="range" min="5" max="25" value={d.roundsTotal}
                      onChange={(e) => setD({ roundsTotal: parseInt(e.target.value, 10) })}
                      className="w-full" />
                    <div className={["w-10 text-right text-sm font-semibold", themeTokens.textStrong].join(" ")}>
                      {d.roundsTotal}
                    </div>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("timer")}</div>
                  <div className="mt-2 flex items-center justify-between gap-3">
                    <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("timerEnabled")}</div>
                    <button onClick={() => setD({ timerEnabled: !d.timerEnabled })}
                      className={["rounded-lg px-3 py-2 text-sm ring-1 transition",
                        d.timerEnabled ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {d.timerEnabled ? "On" : "Off"}
                    </button>
                  </div>
                  <div className="mt-3 flex items-center gap-2">
                    <div className={["text-sm w-40", themeTokens.textMuted].join(" ")}>{t("secondsPerRound")}</div>
                    <input type="number" min="5" max="120"
                      value={d.secondsPerRound}
                      disabled={!d.timerEnabled}
                      onChange={(e) => setD({ secondsPerRound: clamp(parseInt(e.target.value || "0", 10), 5, 120) })}
                      className={["flex-1 rounded-xl ring-1 px-3 py-2 text-sm disabled:opacity-50",
                        themeTokens.input, themeTokens.ring].join(" ")} />
                  </div>
                </div>
              </div>

              <div className="mt-4 flex gap-2">
                <button onClick={() => { setSettings(d); onClose(); }}
                  className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                  {t("save")}
                </button>
                <button onClick={onClose}
                  className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                  {t("close")}
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function RevealModal({ open, t, themeTokens, payload, onNext }) {
      if (!open || !payload) return null;

      const Row = ({ k, v }) => (
        <div className="flex items-center justify-between gap-3">
          <div className={["text-sm", themeTokens.textMuted].join(" ")}>{k}</div>
          <div className={["text-sm font-semibold text-right", themeTokens.textStrong].join(" ")}>{v}</div>
        </div>
      );

      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/65 backdrop-blur-sm"></div>
          <div className="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3 sm:p-6">
            <div className={["w-full sm:max-w-lg rounded-2xl ring-1 p-5 pop", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className="flex items-start justify-between gap-3">
                <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>
                  {payload.correct ? `‚úÖ ${t("correct")}` : `‚ùå ${t("wrong")}`}
                </div>
                <button onClick={onNext} className={["rounded-xl px-3 py-2 ring-1 transition", themeTokens.btnGhost].join(" ")}>
                  {t("next")}
                </button>
              </div>

              <div className={["mt-3 rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                <Row k={t("correctAnswer")} v={payload.correctName} />
                {payload.mode === "choice" && <Row k={t("yourAnswer")} v={payload.yourName} />}
                {payload.mode === "click" && <Row k={t("distance")} v={`${Math.round(payload.distKm)} km`} />}
              </div>

              <div className={["mt-3 rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                <Row k={t("difficulty")} v={`${payload.diff.toFixed(2)} / 5   ${diffStars(payload.diff)}`} />
                <Row k={t("difficultyMult")} v={`√ó${payload.mult.toFixed(2)}`} />
                <Row k={t("points")} v={`${payload.points >= 0 ? "+" : ""}${payload.points}`} />
              </div>

              <div className="mt-4">
                <button onClick={onNext} className={["w-full rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                  {t("proceed")}
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function GameOverModal({ open, t, themeTokens, stats, onClose, onPlayAgain }) {
      if (!open || !stats) return null;

      const confetti = new Array(22).fill(0).map((_, i) => ({
        id: i,
        left: Math.random() * 100,
        delay: Math.random() * 0.7,
        dur: 1.2 + Math.random() * 0.9,
        size: 6 + Math.random() * 8
      }));

      const Card = ({ label, value }) => (
        <div className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
          <div className={["text-xs uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{label}</div>
          <div className={["mt-1 text-3xl font-bold", themeTokens.textStrong].join(" ")}>{value}</div>
        </div>
      );

      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/65 backdrop-blur-sm"></div>

          {confetti.map(c => (
            <div key={c.id}
              className="absolute top-0 rounded-sm opacity-0"
              style={{
                left: `${c.left}%`,
                width: `${c.size}px`,
                height: `${c.size * 1.2}px`,
                background: `hsl(${Math.floor(Math.random()*360)} 85% 60%)`,
                animation: `confettiFall ${c.dur}s ease-in ${c.delay}s 1 forwards`
              }}
            />
          ))}

          <div className="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3 sm:p-6">
            <div className={["w-full sm:max-w-2xl rounded-2xl ring-1 p-5 pop", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className="flex items-start justify-between gap-3">
                <div>
                  <div className={["text-3xl font-extrabold", themeTokens.textStrong].join(" ")}>
                    üéâ {t("gameOverTitle")}
                  </div>
                  <div className={["text-sm mt-1", themeTokens.textMuted].join(" ")}>
                    {t("gameOverBody")}
                  </div>
                </div>
                <button onClick={onClose} className={["rounded-xl px-3 py-2 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                  {t("close")}
                </button>
              </div>

              <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
                <Card label={t("score")} value={stats.score} />
                <Card label={t("accuracy")} value={formatPct(stats.accuracy)} />
                <Card label={t("summaryCorrect")} value={stats.correct} />
                <Card label={t("summaryWrong")} value={stats.wrong} />
              </div>

              <div className={["mt-3 rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                <div className={["text-sm", themeTokens.textMuted].join(" ")}>
                  {t("summaryMode")}: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{stats.mode}</span> ¬∑
                  {" "}{t("summaryRounds")}: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{stats.rounds}</span>
                </div>
              </div>

              <div className="mt-4">
                <button onClick={onPlayAgain} className={["w-full rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                  {t("playAgain")}
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // -------------------------
    // Globe component
    // -------------------------
    function GlobeView({
      countries,
      targetId,
      mode,
      reduceMotion,
      onClickLatLng,
      getFeatureStats,
      theme,
      borderIntensity,
      revealTarget,
      locked,
      clickMarker,
      targetMarker
    }) {
      const containerRef = useRef(null);
      const globeRef = useRef(null);
      const gestureRef = useRef({ downX: 0, downY: 0, downT: 0, active: false });

      const globeAssets = useMemo(() => {
        if (theme === "light") {
          return {
            bg: "#eaf2ff",
            atmosphere: "#0ea5e9",
            globeImg: "https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg",
            bumpImg: "https://unpkg.com/three-globe/example/img/earth-topology.png",
          };
        }
        return {
          bg: "#05070b",
          atmosphere: "#67e8f9",
          globeImg: "https://unpkg.com/three-globe/example/img/earth-night.jpg",
          bumpImg: "https://unpkg.com/three-globe/example/img/earth-topology.png",
        };
      }, [theme]);

      // Keep borders stable & visible. Use only supported globe.gl APIs (no polygonStrokeWidth).
      const borderStyle = useMemo(() => {
        const I = clamp(borderIntensity ?? 0.8, 0, 1);
        if (theme === "light") {
          const strokeA = 0.35 + 0.60 * I;   // 0.35..0.95
          const capA    = 0.010 + 0.030 * I; // keep near transparent to avoid z-fighting
          const targetA = 0.55 + 0.35 * I;
          return {
            stroke: `rgba(2,6,23,${strokeA.toFixed(3)})`,
            cap: `rgba(2,6,23,${capA.toFixed(3)})`,
            capTarget: `rgba(16,185,129,${targetA.toFixed(3)})`,
            capReveal: `rgba(59,130,246,${(0.60 + 0.30*I).toFixed(3)})`,
            side: `rgba(0,0,0,0)`
          };
        } else {
          const strokeA = 0.30 + 0.60 * I;   // 0.30..0.90
          const capA    = 0.015 + 0.030 * I; // low cap alpha reduces flicker
          const targetA = 0.55 + 0.35 * I;
          return {
            stroke: `rgba(226,232,240,${strokeA.toFixed(3)})`,
            cap: `rgba(148,163,184,${capA.toFixed(3)})`,
            capTarget: `rgba(16,185,129,${targetA.toFixed(3)})`,
            capReveal: `rgba(96,165,250,${(0.60 + 0.30*I).toFixed(3)})`,
            side: `rgba(0,0,0,0)`
          };
        }
      }, [theme, borderIntensity]);

      useEffect(() => {
        const el = containerRef.current;
        if (!el) return;

        const globe = Globe()(el)
          .backgroundColor(globeAssets.bg)
          .showAtmosphere(true)
          .atmosphereColor(globeAssets.atmosphere)
          .atmosphereAltitude(0.14)
          .globeImageUrl(globeAssets.globeImg)
          .bumpImageUrl(globeAssets.bumpImg)
          .enablePointerInteraction(true);

        const controls = globe.controls();
        controls.enableDamping = false;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 0.7;
        controls.minDistance = 180;
        controls.maxDistance = 520;
        controls.enablePan = false;

        try { globe.camera().up.set(0, 1, 0); } catch {}

        const scene = globe.scene();
        scene.add(new THREE.AmbientLight(0xffffff, theme === "light" ? 0.95 : 0.6));
        const dir = new THREE.DirectionalLight(0xffffff, theme === "light" ? 1.1 : 0.9);
        dir.position.set(-100, 200, 300);
        scene.add(dir);

        const ro = new ResizeObserver(() => {
          const { width, height } = el.getBoundingClientRect();
          globe.width(width);
          globe.height(height);
        });
        ro.observe(el);

        const { width, height } = el.getBoundingClientRect();
        globe.width(width);
        globe.height(height);

        globe.pointOfView({ lat: 15, lng: 10, altitude: 2.2 }, 0);

        globeRef.current = globe;
        return () => { try { ro.disconnect(); } catch {} globeRef.current = null; };
      }, []);

      useEffect(() => {
        const globe = globeRef.current;
        if (!globe) return;
        globe.backgroundColor(globeAssets.bg);
        globe.atmosphereColor(globeAssets.atmosphere);
        globe.globeImageUrl(globeAssets.globeImg);
        globe.bumpImageUrl(globeAssets.bumpImg);
      }, [globeAssets]);

      // polygons + markers
      useEffect(() => {
        const globe = globeRef.current;
        if (!globe || !countries?.length) return;

        // Slight cap altitude reduces z-fighting flicker
        const baseAlt = 0.014;
        const targetAlt = 0.060;

        globe
          .polygonsData(countries)
          .polygonCapColor(d => {
            if (mode === "choice" && d.id === targetId) return borderStyle.capTarget;
            if (revealTarget && d.id === targetId) return borderStyle.capReveal;
            return borderStyle.cap;
          })
          .polygonSideColor(() => borderStyle.side)
          .polygonStrokeColor(() => borderStyle.stroke)
          .polygonAltitude(d => {
            if (mode === "choice" && d.id === targetId) return targetAlt;
            if (revealTarget && d.id === targetId) return targetAlt;
            return baseAlt;
          })
          .polygonsTransitionDuration(reduceMotion ? 0 : 250);

        const pts = [];
        if (clickMarker) pts.push({ ...clickMarker, kind: "click" });
        if (targetMarker) pts.push({ ...targetMarker, kind: "target" });

        globe
          .pointsData(pts)
          .pointLat(d => d.lat)
          .pointLng(d => d.lng)
          .pointColor(d => d.kind === "click" ? "rgba(251,113,133,0.9)" : "rgba(34,197,94,0.95)")
          .pointAltitude(d => d.kind === "click" ? 0.02 : 0.03)
          .pointRadius(d => d.kind === "click" ? 0.5 : 0.7);

      }, [countries, targetId, mode, reduceMotion, borderStyle, revealTarget, clickMarker, targetMarker]);

      // Click picking (sphere intersection)
      useEffect(() => {
        const el = containerRef.current;
        const globe = globeRef.current;
        if (!el || !globe) return;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const sphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 100);

        function pickLatLng(ev) {
          const rect = el.getBoundingClientRect();
          const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
          mouse.set(x, y);

          const camera = globe.camera();
          let r = 100;
          try {
            if (typeof globe.getGlobeRadius === "function") r = globe.getGlobeRadius();
            else if (typeof globe.globeRadius === "function") r = globe.globeRadius();
          } catch {}
          sphere.radius = r;

          raycaster.setFromCamera(mouse, camera);
          const hit = new THREE.Vector3();
          const ok = raycaster.ray.intersectSphere(sphere, hit);
          if (!ok) return null;

          const lat = deg(Math.asin(hit.y / r));
          const lng = deg(Math.atan2(hit.x, hit.z));
          return { lat, lng };
        }

        function onPointerDown(ev) {
          if (locked) return;
          if (ev.button != null && ev.button !== 0) return;
          gestureRef.current = { downX: ev.clientX, downY: ev.clientY, downT: performance.now(), active: true };
        }

        function onPointerUp(ev) {
          if (locked) return;
          const g = gestureRef.current;
          if (!g.active) return;
          g.active = false;

          const dx = ev.clientX - g.downX;
          const dy = ev.clientY - g.downY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const dt = performance.now() - g.downT;

          // treat as click if not a drag
          if (dist > 7 || dt > 700) return;

          const pt = pickLatLng(ev);
          if (pt) onClickLatLng?.(pt, ev);
        }

        el.addEventListener("pointerdown", onPointerDown, { passive: true });
        el.addEventListener("pointerup", onPointerUp, { passive: true });
        return () => {
          el.removeEventListener("pointerdown", onPointerDown);
          el.removeEventListener("pointerup", onPointerUp);
        };
      }, [onClickLatLng, locked]);

      // Choice mode fly-to (north-up)
      useEffect(() => {
        const globe = globeRef.current;
        if (!globe || !targetId) return;
        if (mode !== "choice") return;

        const st = getFeatureStats?.(targetId);
        if (!st) return;

        const alt = altitudeFromSpan(st.span);
        try { globe.camera().up.set(0, 1, 0); } catch {}
        globe.pointOfView({ lat: st.lat, lng: st.lng, altitude: alt }, reduceMotion ? 0 : 1100);
        try { globe.controls().update(); } catch {}
      }, [targetId, mode, reduceMotion, getFeatureStats]);

      return (
        <div className="relative h-full w-full rounded-2xl overflow-hidden ring-1 ring-black/10">
          <div ref={containerRef} className="absolute inset-0" />
          <div className="pointer-events-none absolute inset-x-0 top-0 p-3">
            <div className="flex items-center justify-between text-xs md:text-sm">
              <span className="inline-flex items-center gap-2 rounded-full bg-black/35 text-white px-3 py-1 ring-1 ring-white/10">
                <span className="h-2 w-2 rounded-full bg-cyan-300/90"></span>
                Drag to rotate ¬∑ Scroll / pinch to zoom
              </span>
              <span className="hidden md:inline-flex items-center gap-2 rounded-full bg-black/20 text-white/90 px-3 py-1 ring-1 ring-white/10">
                Tip: on mobile, use two fingers to scroll the page
              </span>
            </div>
          </div>
        </div>
      );
    }

    // -------------------------
    // App
    // -------------------------
    function App() {
      const [loading, setLoading] = useState(true);
      const [loadErr, setLoadErr] = useState("");

      const [settings, setSettings] = useState(() =>
        normalizeSettings(safeLSGet("globeGuess.settings", DEFAULT_SETTINGS))
      );

      useEffect(() => {
        const s = normalizeSettings(settings);
        safeLSSet("globeGuess.settings", s);
        document.body.style.background = s.theme === "light" ? "#f1f5f9" : "#05070b";
      }, [settings]);

      const t = (key) => I18N?.[settings.lang]?.[key] ?? I18N.en[key] ?? key;

      const themeTokens = useMemo(() => {
        if (settings.theme === "light") {
          return {
            page: "bg-slate-100 text-slate-900",
            panel: "bg-white/85",
            card: "bg-white/65",
            ring: "ring-black/10",
            textStrong: "text-slate-900",
            textMuted: "text-slate-700/80",
            btnPrimary: "bg-sky-600/90 hover:bg-sky-600 text-white ring-sky-500/30",
            btnGhost: "bg-white/60 hover:bg-white ring-black/10 text-slate-900",
            btnSelected: "bg-slate-900 text-white ring-black/20",
            btnUnselected: "bg-white/60 hover:bg-white ring-black/10 text-slate-900",
            input: "bg-white/70 text-slate-900"
          };
        }
        return {
          page: "bg-[#05070b] text-slate-100",
          panel: "bg-slate-950/40",
          card: "bg-black/20",
          ring: "ring-white/10",
          textStrong: "text-slate-100",
          textMuted: "text-slate-200/70",
          btnPrimary: "bg-cyan-500/20 hover:bg-cyan-500/30 text-slate-100 ring-cyan-300/20",
          btnGhost: "bg-black/20 hover:bg-white/5 ring-white/10 text-slate-100",
          btnSelected: "bg-white/10 ring-white/20 text-slate-100",
          btnUnselected: "bg-black/20 hover:bg-white/5 ring-white/10 text-slate-100",
          input: "bg-black/30 text-slate-100"
        };
      }, [settings.theme]);

      // Data
      const [countries, setCountries] = useState([]);
      const [idToName, setIdToName] = useState(new Map());
      const [diffPack, setDiffPack] = useState(null); // { diffById, statsById }

      // Game state
      const [mode, setMode] = useState("click"); // "click" | "choice"
      const [roundIdx, setRoundIdx] = useState(0);
      const [deck, setDeck] = useState([]); // array of country ids in round order
      const [targetId, setTargetId] = useState(null);

      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [correctCount, setCorrectCount] = useState(0);
      const [wrongCount, setWrongCount] = useState(0);

      const [choices, setChoices] = useState([]);
      const [locked, setLocked] = useState(false);

      const [revealOpen, setRevealOpen] = useState(false);
      const [revealPayload, setRevealPayload] = useState(null);
      const [revealTarget, setRevealTarget] = useState(false);

      const [clickMarker, setClickMarker] = useState(null);
      const [targetMarker, setTargetMarker] = useState(null);

      const [settingsOpen, setSettingsOpen] = useState(false);
      const [gameOverOpen, setGameOverOpen] = useState(false);

      const reduceMotion = useMemo(() => {
        try { return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches; }
        catch { return false; }
      }, []);

      // Highscores
      const [highscores, setHighscores] = useState(() => safeLSGet("globeGuess.highscores", {
        click: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
        choice: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
      }));

      useEffect(() => safeLSSet("globeGuess.highscores", highscores), [highscores]);

      // Load local world geometry + names
      useEffect(() => {
        (async () => {
          setLoading(true);
          setLoadErr("");
          try {
            const topoRes = await fetch("./data/countries-110m.json", { cache: "no-store" });
            if (!topoRes.ok) throw new Error(`countries-110m.json HTTP ${topoRes.status}`);
            const topo = await topoRes.json();

            const geo = topojson.feature(topo, topo.objects.countries);
            const feats = (geo?.features || []).map(f => ({
              ...f,
              id: String(f.id)
            }));

            // names TSV
            const namesRes = await fetch("./data/country-names.tsv", { cache: "no-store" });
            if (!namesRes.ok) throw new Error(`country-names.tsv HTTP ${namesRes.status}`);
            const tsv = await namesRes.text();

            const map = new Map();
            const lines = tsv.split(/\r?\n/).filter(Boolean);
            const header = lines[0].split("\t").map(s => s.trim().toLowerCase());
            let idIdx = header.findIndex(h => h === "id" || h === "iso_n3" || h.includes("id"));
            let nameIdx = header.findIndex(h => h === "name" || h.includes("country") || h.includes("admin"));

            // fallback if no header
            if (idIdx < 0 || nameIdx < 0) { idIdx = 0; nameIdx = 1; }

            for (let i = 1; i < lines.length; i++) {
              const cols = lines[i].split("\t");
              const id = String((cols[idIdx] || "").trim());
              const name = String((cols[nameIdx] || "").trim());
              if (id && name) map.set(id, name);
            }

            // Filter out countries without a name (prevents ‚Äúdisabled option‚Äù bugs)
            const withNames = feats.filter(f => map.has(String(f.id)));
            setCountries(withNames);
            setIdToName(map);

            const pack = computeDifficultyForCountries(withNames, map);
            setDiffPack(pack);

            setLoading(false);
          } catch (e) {
            setLoadErr(String(e?.message || e));
            setLoading(false);
          }
        })();
      }, []);

      const getFeatureStatsById = useMemo(() => {
        if (!diffPack?.statsById) return null;
        return (id) => diffPack.statsById.get(String(id));
      }, [diffPack]);

      const getDiffById = useMemo(() => {
        if (!diffPack?.diffById) return null;
        return (id) => diffPack.diffById.get(String(id));
      }, [diffPack]);

      const accuracy = useMemo(() => {
        const total = correctCount + wrongCount;
        return total ? correctCount / total : NaN;
      }, [correctCount, wrongCount]);

      // Build a deck with "difficulty climax"
      function buildDeckForGame(modeForDeck) {
        const N = settings.roundsTotal;
        const maxD = settings.maxDifficulty;

        const pool = countries
          .map(f => String(f.id))
          .filter(id => {
            const d = getDiffById?.(id)?.difficulty ?? 3;
            return d <= maxD && idToName.has(id);
          });

        // if pool too small, fallback to all named countries
        const safePool = pool.length >= N ? pool : countries.map(f => String(f.id)).filter(id => idToName.has(id));

        // sort by difficulty ascending
        const sorted = safePool.slice().sort((a, b) => (getDiffById?.(a)?.difficulty ?? 3) - (getDiffById?.(b)?.difficulty ?? 3));

        const minD = getDiffById?.(sorted[0])?.difficulty ?? 1;
        const maxAllowed = Math.min(maxD, getDiffById?.(sorted[sorted.length - 1])?.difficulty ?? maxD);

        const remaining = new Set(sorted);
        const deckOut = [];

        for (let i = 0; i < N; i++) {
          const alpha = N === 1 ? 1 : (i / (N - 1));
          const targetMax = minD + (maxAllowed - minD) * alpha;

          // candidates <= targetMax (climax)
          const cand = [];
          for (const id of remaining) {
            const d = getDiffById?.(id)?.difficulty ?? 3;
            if (d <= targetMax + 1e-6) cand.push(id);
          }

          let pick;
          if (cand.length) {
            // pick from the top third of candidates to steadily increase
            cand.sort((a,b)=> (getDiffById?.(a)?.difficulty ?? 3) - (getDiffById?.(b)?.difficulty ?? 3));
            const start = Math.floor(cand.length * 0.55);
            const slice = cand.slice(start);
            pick = pickRandom(slice.length ? slice : cand);
          } else {
            // if none below threshold, pick easiest remaining
            const remArr = Array.from(remaining);
            remArr.sort((a,b)=> (getDiffById?.(a)?.difficulty ?? 3) - (getDiffById?.(b)?.difficulty ?? 3));
            pick = remArr[0];
          }

          remaining.delete(pick);
          deckOut.push(pick);
        }

        return deckOut;
      }

      // Prepare choices (8 options)
      function buildChoices(target) {
        const targetName = idToName.get(String(target));
        const pool = countries.map(f => String(f.id)).filter(id => id !== String(target) && idToName.has(id));

        // sample 7 distractors, prefer similar difficulty
        const targetDiff = getDiffById?.(target)?.difficulty ?? 3;
        const near = pool
          .map(id => ({ id, d: getDiffById?.(id)?.difficulty ?? 3 }))
          .sort((a,b)=> Math.abs(a.d - targetDiff) - Math.abs(b.d - targetDiff))
          .slice(0, Math.min(80, pool.length))
          .map(x => x.id);

        const distractors = shuffle(near).slice(0, 7);
        const all = shuffle([String(target), ...distractors]).map(id => ({
          id,
          name: idToName.get(id),
          correct: id === String(target)
        }));
        return all;
      }

      function resetGame(newMode = mode) {
        if (!countries.length || !idToName.size || !getDiffById) return;

        setMode(newMode);
        setScore(0);
        setStreak(0);
        setCorrectCount(0);
        setWrongCount(0);
        setRoundIdx(0);
        setRevealOpen(false);
        setRevealPayload(null);
        setRevealTarget(false);
        setLocked(false);
        setClickMarker(null);
        setTargetMarker(null);
        setGameOverOpen(false);

        const d = buildDeckForGame(newMode);
        setDeck(d);
        const first = d[0];
        setTargetId(first);

        if (newMode === "choice") setChoices(buildChoices(first));
        else setChoices([]);
      }

      // Start first game once data ready (only once)
      useEffect(() => {
        if (!loading && !loadErr && countries.length && idToName.size && getDiffById && deck.length === 0) {
          resetGame("click");
        }
      }, [loading, loadErr, countries.length, idToName.size, !!getDiffById]);

      function endGame() {
        const total = correctCount + wrongCount;
        const acc = total ? correctCount / total : 0;
        const hsKey = mode;
        setHighscores(prev => {
          const old = prev[hsKey] || { bestScore: 0, bestAccuracy: 0, bestStreak: 0 };
          return {
            ...prev,
            [hsKey]: {
              bestScore: Math.max(old.bestScore || 0, score),
              bestAccuracy: Math.max(old.bestAccuracy || 0, acc),
              bestStreak: Math.max(old.bestStreak || 0, streak),
            }
          };
        });
        setGameOverOpen(true);
      }

      function gotoNextQuestion() {
        setRevealOpen(false);
        setRevealPayload(null);
        setRevealTarget(false);
        setLocked(false);
        setClickMarker(null);
        setTargetMarker(null);

        const nextIdx = roundIdx + 1;
        if (nextIdx >= settings.roundsTotal) {
          endGame();
          return;
        }

        setRoundIdx(nextIdx);
        const nextId = deck[nextIdx];
        setTargetId(nextId);

        if (mode === "choice") setChoices(buildChoices(nextId));
        else setChoices([]);
      }

      // Timer (optional) ‚Äî when expires, counts as wrong and reveals
      useEffect(() => {
        if (!settings.timerEnabled) return;
        if (locked || revealOpen || gameOverOpen) return;
        if (!targetId) return;

        const ms = settings.secondsPerRound * 1000;
        const timer = setTimeout(() => {
          // auto-fail
          if (mode === "choice") {
            onChoiceSelect({ id: "__timeout__", name: "‚Äî", correct: false }, true);
          } else {
            onGlobeClick({ lat: 0, lng: 0 }, true); // special fail
          }
        }, ms);

        return () => clearTimeout(timer);
      }, [settings.timerEnabled, settings.secondsPerRound, locked, revealOpen, gameOverOpen, targetId, mode]);

      // Click mode handler
      function onGlobeClick({ lat, lng }, isTimeout = false) {
        if (locked || revealOpen || mode !== "click") return;
        if (!targetId) return;

        setLocked(true);

        const feature = countries.find(f => String(f.id) === String(targetId));
        const dInfo = getDiffById?.(targetId);
        const diff = dInfo?.difficulty ?? 3;
        const mult = difficultyMultiplier(diff);

        const click = isTimeout ? null : { lat, lng };
        if (click) setClickMarker({ lat, lng });

        // show target marker at centroid for learning
        const st = getFeatureStatsById?.(targetId);
        if (st) setTargetMarker({ lat: st.lat, lng: st.lng });

        const { inside, distKm } = (click && feature)
          ? polygonDistanceKmToBorder(lng, lat, feature)
          : { inside: false, distKm: 99999 };

        const { base } = baseScoreClick(inside, distKm);
        const points = Math.round(base * mult);

        const correct = inside; // click mode "correct" = inside border
        setScore(s => s + points);
        if (correct) {
          setCorrectCount(c => c + 1);
          setStreak(s => s + 1);
        } else {
          setWrongCount(w => w + 1);
          setStreak(0);
        }

        // reveal correct country highlight
        setRevealTarget(true);

        setRevealPayload({
          mode: "click",
          correct,
          correctName: idToName.get(String(targetId)) || "‚Äî",
          yourName: "",
          distKm: isTimeout ? 99999 : distKm,
          diff,
          mult,
          points
        });
        setRevealOpen(true);
      }

      // Choice mode handler
      function onChoiceSelect(opt, isTimeout = false) {
        if (locked || revealOpen || mode !== "choice") return;
        if (!targetId) return;

        setLocked(true);

        const correct = !!opt?.correct;
        const dInfo = getDiffById?.(targetId);
        const diff = dInfo?.difficulty ?? 3;
        const mult = difficultyMultiplier(diff);

        setRevealTarget(true);

        setScore(s => {
          const newStreak = correct ? (streak + 1) : 0;
          const base = baseScoreChoice({ correct, newStreak });
          const points = Math.round(base * mult);

          // update streak/correct/wrong
          if (correct) {
            setCorrectCount(c => c + 1);
            setStreak(newStreak);
          } else {
            setWrongCount(w => w + 1);
            setStreak(0);
          }

          setRevealPayload({
            mode: "choice",
            correct,
            correctName: idToName.get(String(targetId)) || "‚Äî",
            yourName: isTimeout ? "‚è±Ô∏è" : (opt?.name || "‚Äî"),
            distKm: 0,
            diff,
            mult,
            points
          });
          setRevealOpen(true);

          return s + points;
        });
      }

      // Switch mode mid-game => start new game
      function setModeAndRestart(m) {
        resetGame(m);
      }

      // Highscore reset
      function resetHighscores() {
        setHighscores({
          click: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
          choice: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
        });
      }

      const currentName = targetId ? (idToName.get(String(targetId)) || "‚Äî") : "‚Äî";
      const currentDiff = targetId ? (getDiffById?.(targetId)?.difficulty ?? 3) : 3;
      const currentMult = difficultyMultiplier(currentDiff);

      const roundLabel = `${roundIdx + 1}/${settings.roundsTotal}`;

      if (loading) {
        return (
          <div className={["h-full flex items-center justify-center", themeTokens.page].join(" ")}>
            <div className={["rounded-2xl ring-1 p-6", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{t("loading")}</div>
            </div>
          </div>
        );
      }

      if (loadErr) {
        return (
          <div className={["h-full flex items-center justify-center p-4", themeTokens.page].join(" ")}>
            <div className={["max-w-xl w-full rounded-2xl ring-1 p-6", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{t("loadFailTitle")}</div>
              <div className={["mt-2 text-sm", themeTokens.textMuted].join(" ")}>{t("loadFailTip")}</div>
              <div className={["mt-4 rounded-xl ring-1 p-3 font-mono text-sm whitespace-pre-wrap", themeTokens.card, themeTokens.ring].join(" ")}>
                {loadErr}
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className={["h-full", themeTokens.page].join(" ")}>
          <div className="h-full max-w-7xl mx-auto p-3 sm:p-4 grid grid-cols-1 lg:grid-cols-12 gap-3 sm:gap-4">
            <div className="lg:col-span-7 h-[52vh] lg:h-full">
              <GlobeView
                countries={countries}
                targetId={targetId}
                mode={mode}
                reduceMotion={reduceMotion}
                onClickLatLng={(pt) => onGlobeClick(pt, false)}
                getFeatureStats={(id) => getFeatureStatsById?.(id)}
                theme={settings.theme}
                borderIntensity={settings.borderIntensity}
                revealTarget={revealTarget}
                locked={locked || revealOpen || gameOverOpen}
                clickMarker={clickMarker}
                targetMarker={targetMarker}
              />
            </div>

            <div className="lg:col-span-5 flex flex-col gap-3 sm:gap-4">
              <div className={["rounded-2xl ring-1 p-4", themeTokens.panel, themeTokens.ring].join(" ")}>
                <div className="flex items-start justify-between gap-3">
                  <div>
                    <div className={["text-3xl font-extrabold leading-tight", themeTokens.textStrong].join(" ")}>{t("title")}</div>
                    <div className={["text-sm mt-1", themeTokens.textMuted].join(" ")}>{t("subtitle")}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 px-3 py-2 text-right", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("round")}</div>
                    <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{roundLabel}</div>
                  </div>
                </div>

                <div className="mt-3 grid grid-cols-4 gap-2">
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("score")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{score}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("streak")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{streak}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("accuracy")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{formatPct(accuracy)}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("mode")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>
                      {mode === "click" ? t("clickMode") : t("choiceMode")}
                    </div>
                  </div>
                </div>

                <div className={["mt-3 rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>
                    {t("difficultyClimax")}
                  </div>
                  <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>
                    {t("difficultyClimaxHint")}
                  </div>

                  <div className="mt-3 flex items-center justify-between gap-3">
                    <div>
                      <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("difficulty")}</div>
                      <div className={["text-lg font-bold", themeTokens.textStrong].join(" ")}>
                        {currentDiff.toFixed(2)} / 5 &nbsp; <span className="text-base">{diffStars(currentDiff)}</span>
                      </div>
                      <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>
                        {t("difficultyMult")}: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>√ó{currentMult.toFixed(2)}</span>
                      </div>
                    </div>
                    <div className="text-right">
                      <div className={["text-sm", themeTokens.textMuted].join(" ")}>
                        {t("round")} {roundLabel}
                      </div>
                    </div>
                  </div>

                  <div className="mt-4">
                    {mode === "click" ? (
                      <>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("findAndClick")}</div>
                        <div className={["mt-1 text-2xl font-extrabold", themeTokens.textStrong].join(" ")}>
                          {currentName}
                        </div>
                        <div className={["mt-2 text-sm", themeTokens.textMuted].join(" ")}>
                          {t("clickAnywhere")}
                        </div>
                        <div className={["mt-2 text-xs", themeTokens.textMuted].join(" ")}>
                          {t("pointsRuleClick")}
                        </div>
                      </>
                    ) : (
                      <>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("highlightedIs")}</div>
                        <div className={["mt-1 text-xs", themeTokens.textMuted].join(" ")}>{t("highlightHint")}</div>

                        <div className="mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2">
                          {choices.map((opt) => (
                            <button
                              key={`${roundIdx}-${opt.id}`}
                              disabled={locked || revealOpen}
                              onClick={() => onChoiceSelect(opt, false)}
                              className={[
                                "rounded-2xl px-3 py-3 ring-1 transition font-semibold text-sm",
                                (locked || revealOpen) ? "opacity-60 cursor-not-allowed" : "",
                                themeTokens.btnGhost
                              ].join(" ")}
                            >
                              {opt.name}
                            </button>
                          ))}
                        </div>

                        <div className={["mt-2 text-xs", themeTokens.textMuted].join(" ")}>
                          {t("pointsRuleChoice")}
                        </div>
                      </>
                    )}
                  </div>
                </div>

                <div className="mt-3 flex gap-2">
                  <button onClick={() => resetGame(mode)} className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                    {t("newGame")}
                  </button>
                  <button onClick={() => setSettingsOpen(true)} className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("settings")}
                  </button>
                  <button onClick={() => setModeAndRestart("click")} className={["rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("clickMode")}
                  </button>
                  <button onClick={() => setModeAndRestart("choice")} className={["rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("choiceMode")}
                  </button>
                </div>
              </div>

              <div className={["rounded-2xl ring-1 p-4", themeTokens.panel, themeTokens.ring].join(" ")}>
                <div className="flex items-center justify-between gap-3">
                  <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{t("highscore")}</div>
                  <button onClick={resetHighscores} className={["rounded-xl px-3 py-2 ring-1 transition text-sm font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("reset")}
                  </button>
                </div>

                <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {["click","choice"].map(k => {
                    const hs = highscores[k];
                    return (
                      <div key={k} className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                        <div className={["text-sm font-bold", themeTokens.textStrong].join(" ")}>
                          {k === "click" ? t("clickMode") : t("choiceMode")}
                        </div>
                        <div className={["mt-2 text-sm", themeTokens.textMuted].join(" ")}>
                          Best score: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{hs.bestScore}</span>
                        </div>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>
                          Best accuracy: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{formatPct(hs.bestAccuracy)}</span>
                        </div>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>
                          Best streak: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{hs.bestStreak}</span>
                        </div>
                      </div>
                    );
                  })}
                </div>

                <div className={["mt-3 rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-lg font-bold", themeTokens.textStrong].join(" ")}>{t("howTo")}</div>
                  <ul className={["mt-2 text-sm space-y-1 list-disc list-inside", themeTokens.textMuted].join(" ")}>
                    <li>{t("howClick")}</li>
                    <li>{t("howChoice")}</li>
                    <li>{t("howDrag")}</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <SettingsModal
            open={settingsOpen}
            t={t}
            themeTokens={themeTokens}
            settings={settings}
            setSettings={(s) => {
              const ns = normalizeSettings(s);
              setSettings(ns);
              // if game is running, rebuild deck to respect difficulty setting (but keep mode)
              resetGame(mode);
            }}
            onClose={() => setSettingsOpen(false)}
          />

          <RevealModal
            open={revealOpen}
            t={t}
            themeTokens={themeTokens}
            payload={revealPayload}
            onNext={gotoNextQuestion}
          />

          <GameOverModal
            open={gameOverOpen}
            t={t}
            themeTokens={themeTokens}
            stats={{
              score,
              accuracy,
              correct: correctCount,
              wrong: wrongCount,
              mode: mode === "click" ? t("clickMode") : t("choiceMode"),
              rounds: settings.roundsTotal
            }}
            onClose={() => setGameOverOpen(false)}
            onPlayAgain={() => { setGameOverOpen(false); resetGame(mode); }}
          />
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
