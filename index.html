<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Globe Guess</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    body { margin: 0; overscroll-behavior: none; }
    * { -webkit-tap-highlight-color: transparent; }
    @keyframes pop { 0%{transform:scale(.98);opacity:0} 100%{transform:scale(1);opacity:1} }
    .pop { animation: pop .16s ease-out; }
  </style>
</head>
<body>
  <div id="root" class="h-full"></div>

  <!-- Difficulty mapping (local file) -->
  <script src="./difficulty-map.js"></script>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Three + Globe.gl -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/globe.gl@2.45.0/dist/globe.gl.min.js"></script>

  <!-- TopoJSON -->
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // -------------------------
    // crypto RNG (better randomness)
    // -------------------------
    function randInt(n) {
      if (n <= 0) return 0;
      const a = new Uint32Array(1);
      crypto.getRandomValues(a);
      return a[0] % n;
    }
    function pickCrypto(arr) { return arr[randInt(arr.length)]; }
    function shuffleCrypto(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = randInt(i + 1);
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // -------------------------
    // i18n (UI only)
    // -------------------------
    const I18N = {
      en: {
        title: "Globe Guess",
        subtitle: "Two modes: click the named country, or pick the right name from 8 options.",
        round: "Round",
        score: "Score",
        streak: "Streak",
        accuracy: "Accuracy",
        mode: "Mode",
        clickMode: "Click",
        choiceMode: "Choice",
        newGame: "New Game",
        settings: "Settings",
        close: "Close",
        save: "Save",
        language: "Language",
        english: "English",
        german: "German",
        theme: "Theme",
        dark: "Dark",
        light: "Light",
        borders: "Borders",
        borderIntensity: "Border intensity",
        roundsPerGame: "Rounds per game",
        timer: "Timer",
        timerEnabled: "Enable timer",
        secondsPerRound: "Seconds per round",
        difficulty: "Difficulty",
        maxDifficulty: "Max difficulty",
        difficultyHint: "Limits the hardest countries in your pool (1..5).",
        next: "Next",
        yourAnswer: "Your answer",
        correctAnswer: "Correct answer",
        distance: "Distance",
        points: "Points",
        findAndClick: "Find and click:",
        clickAnywhere: "Click anywhere on the globe. Score is based on distance to the border.",
        highlightedIs: "The highlighted country is:",
        highlightHint: "(It flies to center + zoom depends on size)",
        loading: "Loading globe…",
        loadFailTitle: "Couldn’t load data",
        loadFailTip: "Host locally: ./data/countries-110m.json and ./data/country-names.tsv (id,en,de)",
        correct: "Correct!",
        wrong: "Wrong",
        gameOverTitle: "Game Over",
        gameOverBody: "Here are your stats.",
        playAgain: "Play again",
        summaryMode: "Mode",
        summaryRounds: "Rounds",
        summaryCorrect: "Correct",
        summaryWrong: "Wrong",
        highscore: "Highscores",
        reset: "Reset",
        howTo: "How it works",
        howClick: "Click Mode: you’re told a country name; click/tap on the globe.",
        howChoice: "Choice Mode: the correct country is raised/green; pick its name from 8 options.",
        howDrag: "Drag to rotate, pinch/scroll to zoom.",
        pointsRuleClick: "Click: inside=10, outside=max(0,10-floor(distance_km/100))",
        pointsRuleChoice: "Choice: correct=100 + 15*(streak-1), wrong=-25",
        difficultyMult: "Difficulty multiplier",
        revealTitle: "Answer",
        proceed: "Continue",
        difficultyClimax: "Difficulty climax",
        difficultyClimaxHint: "Easier early rounds, harder later rounds.",
        learnLog: "Learning log",
        downloadCSV: "Download CSV",
        resetLog: "Reset log"
      },
      de: {
        title: "Globus-Quiz",
        subtitle: "Zwei Modi: Klicke das genannte Land oder wähle den richtigen Namen aus 8 Optionen.",
        round: "Runde",
        score: "Punkte",
        streak: "Serie",
        accuracy: "Trefferquote",
        mode: "Modus",
        clickMode: "Klick",
        choiceMode: "Auswahl",
        newGame: "Neues Spiel",
        settings: "Einstellungen",
        close: "Schließen",
        save: "Speichern",
        language: "Sprache",
        english: "Englisch",
        german: "Deutsch",
        theme: "Theme",
        dark: "Dunkel",
        light: "Hell",
        borders: "Grenzen",
        borderIntensity: "Grenz-Intensität",
        roundsPerGame: "Runden pro Spiel",
        timer: "Timer",
        timerEnabled: "Timer aktivieren",
        secondsPerRound: "Sekunden pro Runde",
        difficulty: "Schwierigkeit",
        maxDifficulty: "Max. Schwierigkeit",
        difficultyHint: "Begrenzt die schwierigsten Länder im Pool (1..5).",
        next: "Weiter",
        yourAnswer: "Deine Antwort",
        correctAnswer: "Richtige Antwort",
        distance: "Distanz",
        points: "Punkte",
        findAndClick: "Finde und klicke:",
        clickAnywhere: "Klicke irgendwo auf den Globus. Punkte basieren auf Distanz zur Grenze.",
        highlightedIs: "Das markierte Land ist:",
        highlightHint: "(Fliegt ins Zentrum + Zoom je nach Größe)",
        loading: "Globus wird geladen…",
        loadFailTitle: "Daten konnten nicht geladen werden",
        loadFailTip: "Lokal hosten: ./data/countries-110m.json und ./data/country-names.tsv (id,en,de)",
        correct: "Richtig!",
        wrong: "Falsch",
        gameOverTitle: "Spiel vorbei",
        gameOverBody: "Hier sind deine Statistiken.",
        playAgain: "Nochmal spielen",
        summaryMode: "Modus",
        summaryRounds: "Runden",
        summaryCorrect: "Richtig",
        summaryWrong: "Falsch",
        highscore: "Highscores",
        reset: "Reset",
        howTo: "So funktioniert’s",
        howClick: "Klick-Modus: Du bekommst einen Ländernamen und klickst/tippst auf den Globus.",
        howChoice: "Auswahl-Modus: Das richtige Land ist erhöht/grün; wähle den Namen aus 8 Optionen.",
        howDrag: "Ziehen zum Drehen, Pinch/Scroll zum Zoomen.",
        pointsRuleClick: "Klick: innen=10, außen=max(0,10-floor(distanz_km/100))",
        pointsRuleChoice: "Auswahl: richtig=100 + 15*(serie-1), falsch=-25",
        difficultyMult: "Schwierigkeits-Multiplikator",
        revealTitle: "Antwort",
        proceed: "Weiter",
        difficultyClimax: "Schwierigkeits-Klimax",
        difficultyClimaxHint: "Leicht am Anfang, später schwieriger.",
        learnLog: "Lernprotokoll",
        downloadCSV: "CSV herunterladen",
        resetLog: "Protokoll löschen"
      }
    };

    // -------------------------
    // utils
    // -------------------------
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const rad = (d) => d * Math.PI / 180;
    const deg = (r) => r * 180 / Math.PI;
    const fmtPct = (x) => isFinite(x) ? `${Math.round(x*100)}%` : "—";

    // -------------------------
    // localStorage helpers
    // -------------------------
    const DEFAULT_SETTINGS = {
      lang: "en",
      theme: "dark",
      borderIntensity: 0.8,
      roundsTotal: 10,
      timerEnabled: false,
      secondsPerRound: 20,
      maxDifficulty: 5.0
    };

    function safeLSGet(key, fallback) {
      try { const raw = localStorage.getItem(key); return raw == null ? fallback : JSON.parse(raw); }
      catch { return fallback; }
    }
    function safeLSSet(key, val) {
      try { localStorage.setItem(key, JSON.stringify(val)); } catch {}
    }
    function normalizeSettings(maybe) {
      const s = { ...DEFAULT_SETTINGS, ...(maybe && typeof maybe === "object" ? maybe : {}) };
      s.lang = (s.lang === "de" || s.lang === "en") ? s.lang : DEFAULT_SETTINGS.lang;
      s.theme = (s.theme === "light" || s.theme === "dark") ? s.theme : DEFAULT_SETTINGS.theme;
      s.borderIntensity = clamp(Number(s.borderIntensity ?? DEFAULT_SETTINGS.borderIntensity), 0, 1);
      s.roundsTotal = clamp(parseInt(s.roundsTotal ?? DEFAULT_SETTINGS.roundsTotal, 10), 5, 25);
      s.timerEnabled = !!s.timerEnabled;
      s.secondsPerRound = clamp(parseInt(s.secondsPerRound ?? DEFAULT_SETTINGS.secondsPerRound, 10), 5, 120);
      s.maxDifficulty = clamp(Number(s.maxDifficulty ?? DEFAULT_SETTINGS.maxDifficulty), 1, 5);
      return s;
    }

    // -------------------------
    // geometry helpers
    // -------------------------
    function normLonNear(lon, refLon) {
      let x = lon;
      while (x - refLon > 180) x -= 360;
      while (x - refLon < -180) x += 360;
      return x;
    }
    function projectEquirect(lon, lat, lat0Deg, refLonDeg) {
      const lat0 = rad(lat0Deg);
      const lonN = normLonNear(lon, refLonDeg);
      const x = rad(lonN - refLonDeg) * Math.cos(lat0);
      const y = rad(lat - lat0Deg);
      return { x, y };
    }
    function pointInRingProjected(px, py, ringXY) {
      let inside = false;
      for (let i = 0, j = ringXY.length - 1; i < ringXY.length; j = i++) {
        const xi = ringXY[i].x, yi = ringXY[i].y;
        const xj = ringXY[j].x, yj = ringXY[j].y;
        const intersect = ((yi > py) !== (yj > py)) &&
          (px < (xj - xi) * (py - yi) / (yj - yi + 1e-18) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function distPointToSegment(px, py, ax, ay, bx, by) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const ab2 = abx*abx + aby*aby;
      let t = ab2 > 0 ? (apx*abx + apy*aby) / ab2 : 0;
      t = clamp(t, 0, 1);
      const cx = ax + t * abx;
      const cy = ay + t * aby;
      const dx = px - cx, dy = py - cy;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function polygonDistanceKmToBorder(pointLon, pointLat, feature) {
      const lat0 = pointLat;
      const refLon = pointLon;
      const geom = feature.geometry;
      if (!geom) return { inside: false, distKm: 1e9 };

      const polys = [];
      if (geom.type === "Polygon") polys.push(geom.coordinates);
      else if (geom.type === "MultiPolygon") for (const p of geom.coordinates) polys.push(p);
      else return { inside: false, distKm: 1e9 };

      const p = projectEquirect(pointLon, pointLat, lat0, refLon);
      const px = p.x, py = p.y;

      let inside = false;
      let minDistRad = Infinity;

      for (const poly of polys) {
        if (!poly || !poly.length) continue;
        const outer = poly[0];
        if (!outer || outer.length < 3) continue;

        const outerXY = outer.map(([lon, lat]) => projectEquirect(lon, lat, lat0, refLon));
        const inOuter = pointInRingProjected(px, py, outerXY);

        let inHole = false;
        for (let h = 1; h < poly.length; h++) {
          const hole = poly[h];
          if (!hole || hole.length < 3) continue;
          const holeXY = hole.map(([lon, lat]) => projectEquirect(lon, lat, lat0, refLon));
          if (pointInRingProjected(px, py, holeXY)) { inHole = true; break; }
        }
        if (inOuter && !inHole) inside = true;

        const ringsToMeasure = [outer, ...poly.slice(1)];
        for (const ring of ringsToMeasure) {
          if (!ring || ring.length < 2) continue;
          const ringXY = ring.map(([lon, lat]) => projectEquirect(lon, lat, lat0, refLon));
          for (let i = 0; i < ringXY.length - 1; i++) {
            const a = ringXY[i], b = ringXY[i + 1];
            const d = distPointToSegment(px, py, a.x, a.y, b.x, b.y);
            if (d < minDistRad) minDistRad = d;
          }
        }
      }

      const EARTH_R = 6371;
      const distKm = isFinite(minDistRad) ? (minDistRad * EARTH_R) : 1e9;
      return { inside, distKm };
    }

    function featureStats(feature) {
      const geom = feature?.geometry;
      if (!geom) return null;

      const points = [];
      const pushRing = (ring) => {
        for (const [lon, lat] of ring) {
          if (isFinite(lon) && isFinite(lat)) points.push([lon, lat]);
        }
      };

      let parts = 1;
      let vertices = 0;

      if (geom.type === "Polygon") {
        parts = 1;
        for (const ring of geom.coordinates) {
          vertices += (ring?.length || 0);
          pushRing(ring);
        }
      } else if (geom.type === "MultiPolygon") {
        parts = geom.coordinates.length || 1;
        for (const poly of geom.coordinates) {
          for (const ring of poly) {
            vertices += (ring?.length || 0);
            pushRing(ring);
          }
        }
      } else return null;

      if (!points.length) return null;

      let lon0 = points[0][0];
      let sumLon = 0, sumLat = 0;
      let minLat =  90, maxLat = -90;
      let minLonU =  1e9, maxLonU = -1e9;

      for (const [lonRaw, lat] of points) {
        let lon = lonRaw;
        while (lon - lon0 > 180) lon -= 360;
        while (lon - lon0 < -180) lon += 360;

        sumLon += lon;
        sumLat += lat;

        minLat = Math.min(minLat, lat);
        maxLat = Math.max(maxLat, lat);
        minLonU = Math.min(minLonU, lon);
        maxLonU = Math.max(maxLonU, lon);
      }

      let lng = sumLon / points.length;
      let lat = sumLat / points.length;
      while (lng > 180) lng -= 360;
      while (lng < -180) lng += 360;

      const latSpan = Math.max(0.1, maxLat - minLat);
      const lonSpan = Math.max(0.1, maxLonU - minLonU);
      const effLonSpan = lonSpan * Math.cos(rad(lat));
      const span = Math.max(latSpan, effLonSpan);

      return { lat, lng, span, parts, vertices };
    }

    function altitudeFromSpan(spanDeg) {
      const s = clamp(spanDeg, 0.8, 140);
      const alt = 0.95 + (s / 60) * 1.25;
      return clamp(alt, 1.05, 2.8);
    }

    // Midpoint for label (simple spherical midpoint)
    function midPointLatLng(a, b) {
      const lat1 = rad(a.lat), lon1 = rad(a.lng);
      const lat2 = rad(b.lat), lon2 = rad(b.lng);

      const x1 = Math.cos(lat1) * Math.cos(lon1);
      const y1 = Math.cos(lat1) * Math.sin(lon1);
      const z1 = Math.sin(lat1);

      const x2 = Math.cos(lat2) * Math.cos(lon2);
      const y2 = Math.cos(lat2) * Math.sin(lon2);
      const z2 = Math.sin(lat2);

      const x = x1 + x2;
      const y = y1 + y2;
      const z = z1 + z2;

      const hyp = Math.sqrt(x*x + y*y);
      const lat = Math.atan2(z, hyp);
      const lon = Math.atan2(y, x);

      return { lat: deg(lat), lng: deg(lon) };
    }

    // -------------------------
    // Difficulty computation
    // -------------------------
    function bigramSet(s) {
      const t = (s || "").toLowerCase().replace(/[^a-z0-9]+/g, " ").trim();
      const a = [];
      for (let i = 0; i < t.length - 1; i++) a.push(t.slice(i, i + 2));
      return new Set(a);
    }
    function jaccard(a, b) {
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      const union = a.size + b.size - inter;
      return union ? inter / union : 0;
    }
    function haversineKm(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = rad(lat2 - lat1);
      const dLon = rad(lon2 - lon1);
      const s1 = Math.sin(dLat / 2);
      const s2 = Math.sin(dLon / 2);
      const a = s1*s1 + Math.cos(rad(lat1))*Math.cos(rad(lat2))*s2*s2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function computeDifficultyForCountries(countries, idToNameEN) {
      const D = window.DIFFICULTY_MAP;
      const weights = D?.WEIGHTS ?? { familiarity: .4, geo: .3, region: .2, name: .1 };

      const statsById = new Map();
      for (const f of countries) statsById.set(String(f.id), featureStats(f));

      const ids = countries.map(f => String(f.id));
      const spans = [];
      const parts = [];
      const verts = [];

      for (const id of ids) {
        const st = statsById.get(id);
        if (!st) continue;
        spans.push(st.span);
        parts.push(st.parts);
        verts.push(st.vertices);
      }

      const minSpan = Math.min(...spans), maxSpan = Math.max(...spans);
      const minParts = Math.min(...parts), maxParts = Math.max(...parts);
      const minVerts = Math.min(...verts), maxVerts = Math.max(...verts);

      const norm01 = (v, a, b) => {
        if (!isFinite(v)) return 0.5;
        if (b <= a) return 0.5;
        return clamp((v - a) / (b - a), 0, 1);
      };

      const centroid = ids.map(id => {
        const st = statsById.get(id);
        return st ? { id, lat: st.lat, lng: st.lng } : null;
      }).filter(Boolean);

      const neighborAvgDist = new Map();
      const distsAll = [];

      for (const a of centroid) {
        const dists = [];
        for (const b of centroid) {
          if (a.id === b.id) continue;
          dists.push(haversineKm(a.lat, a.lng, b.lat, b.lng));
        }
        dists.sort((x,y)=>x-y);
        const k = dists.slice(0, 5);
        const avg = k.reduce((s,v)=>s+v,0) / Math.max(1, k.length);
        neighborAvgDist.set(a.id, avg);
        distsAll.push(avg);
      }
      const minN = Math.min(...distsAll), maxN = Math.max(...distsAll);

      const nameBigrams = new Map();
      for (const id of ids) nameBigrams.set(id, bigramSet(idToNameEN.get(id) || ""));

      const nameAmb = new Map();
      for (const idA of ids) {
        const setA = nameBigrams.get(idA);
        let best = 0;
        for (const idB of ids) {
          if (idA === idB) continue;
          best = Math.max(best, jaccard(setA, nameBigrams.get(idB)));
        }
        const nameA = idToNameEN.get(idA) || "";
        const boost = D?.nameAmbiguityBoost ? D.nameAmbiguityBoost(nameA) : 0;
        nameAmb.set(idA, clamp(0.55*boost + 0.45*best, 0, 1));
      }

      const diffById = new Map();
      for (const id of ids) {
        const st = statsById.get(id);
        const nameEN = idToNameEN.get(id) || "";

        const familiarity = D?.familiarityScore ? D.familiarityScore(nameEN) : 0.45;

        const spanN = st ? norm01(st.span, minSpan, maxSpan) : 0.5;
        const invSpan = 1 - spanN;
        const partsN = st ? norm01(st.parts, minParts, maxParts) : 0.0;
        const vertsN = st ? norm01(st.vertices, minVerts, maxVerts) : 0.5;

        let geo = clamp(0.55*invSpan + 0.25*partsN + 0.20*vertsN, 0, 1);

        const nAvg = neighborAvgDist.get(id);
        const nNorm = norm01(nAvg, minN, maxN);
        const region = clamp(1 - nNorm, 0, 1);

        const nameScore = nameAmb.get(id) ?? 0;

        const o = (D?.OVERRIDES && nameEN && D.OVERRIDES[nameEN]) ? D.OVERRIDES[nameEN] : null;
        const fam2 = o?.familiarity != null ? clamp(o.familiarity,0,1) : familiarity;
        const geo2 = o?.geo != null ? clamp(o.geo,0,1) : geo;
        const reg2 = o?.region != null ? clamp(o.region,0,1) : region;
        const nam2 = o?.name != null ? clamp(o.name,0,1) : nameScore;

        const mix =
          weights.familiarity * fam2 +
          weights.geo         * geo2 +
          weights.region      * reg2 +
          weights.name        * nam2;

        const difficulty = clamp(1 + 4 * mix, 1, 5);
        diffById.set(id, { difficulty, mix, familiarity:fam2, geo:geo2, region:reg2, name:nam2 });
      }

      return { diffById, statsById };
    }

    function diffStars(diff) {
      const full = clamp(Math.round(diff), 1, 5);
      return "★".repeat(full) + "☆".repeat(5 - full);
    }

    function difficultyMultiplier(diff) {
      const t = (clamp(diff, 1, 5) - 1) / 4;
      return 0.85 + 0.40 * t; // 0.85..1.25
    }

    function baseScoreClick(inside, distKm) {
      if (inside) return { base: 10, distKm: 0 };
      const bins = Math.floor(distKm / 100);
      const base = Math.max(0, 10 - bins);
      return { base, distKm };
    }
    function baseScoreChoice({ correct, newStreak }) {
      if (correct) return 100 + 15 * (newStreak - 1);
      return -25;
    }

    // -------------------------
    // Learning log
    // -------------------------
    const LEARN_KEY = "globeGuess.learnLog";
    function readLearnLog() {
      const obj = safeLSGet(LEARN_KEY, {});
      return (obj && typeof obj === "object") ? obj : {};
    }
    function writeLearnLog(obj) { safeLSSet(LEARN_KEY, obj); }

    function updateLearnLog(countryId, wasCorrect) {
      const id = String(countryId);
      const log = readLearnLog();
      const e = log[id] || { seen: 0, correct: 0, wrong: 0, last: null };
      e.seen += 1;
      if (wasCorrect) e.correct += 1;
      else e.wrong += 1;
      e.last = new Date().toISOString();
      log[id] = e;
      writeLearnLog(log);
    }

    function downloadCSV({ idToEN, idToDE, countries }) {
      const log = readLearnLog();
      const rows = [];
      rows.push(["id","name_en","name_de","seen","correct","wrong","accuracy","last"].join(","));

      const allIds = countries.map(f => String(f.id));
      for (const id of allIds) {
        const e = log[id];
        if (!e) continue;
        const en = (idToEN.get(id) || "").replaceAll('"','""');
        const de = (idToDE.get(id) || "").replaceAll('"','""');
        const acc = e.seen ? (e.correct / e.seen) : 0;
        const row = [
          id,
          `"${en}"`,
          `"${de}"`,
          e.seen,
          e.correct,
          e.wrong,
          acc.toFixed(3),
          e.last ? `"${e.last}"` : ""
        ].join(",");
        rows.push(row);
      }

      const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "globe-guess-learning-log.csv";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    function resetLearnLog() { writeLearnLog({}); }

    // -------------------------
    // UI: Settings modal
    // -------------------------
    function SettingsModal({ open, t, themeTokens, settings, setSettings, onClose, onDownloadCSV, onResetLog }) {
      const [draft, setDraft] = useState(settings);
      useEffect(() => { if (open) setDraft(settings); }, [open]);

      if (!open) return null;
      const d = normalizeSettings(draft);
      const setD = (patch) => setDraft(prev => normalizeSettings({ ...normalizeSettings(prev), ...patch }));

      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/60 backdrop-blur-sm" onClick={onClose}></div>
          <div className="absolute inset-x-0 bottom-0 sm:inset-0 sm:flex sm:items-center sm:justify-center p-3 sm:p-6">
            <div className={["w-full sm:max-w-lg rounded-2xl ring-1 p-4 sm:p-5 pop", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className="flex items-start justify-between gap-3">
                <div>
                  <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{t("settings")}</div>
                  <div className={["text-sm mt-1", themeTokens.textMuted].join(" ")}>{t("subtitle")}</div>
                </div>
                <button onClick={onClose} className={["rounded-xl px-3 py-2 ring-1 transition", themeTokens.btnGhost].join(" ")}>
                  {t("close")}
                </button>
              </div>

              <div className="mt-4 grid gap-3">
                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("language")}</div>
                  <div className="mt-2 flex gap-2">
                    <button onClick={() => setD({ lang: "en" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.lang === "en" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("english")}
                    </button>
                    <button onClick={() => setD({ lang: "de" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.lang === "de" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("german")}
                    </button>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("theme")}</div>
                  <div className="mt-2 flex gap-2">
                    <button onClick={() => setD({ theme: "dark" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.theme === "dark" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("dark")}
                    </button>
                    <button onClick={() => setD({ theme: "light" })}
                      className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold",
                        d.theme === "light" ? themeTokens.btnSelected : themeTokens.btnUnselected].join(" ")}>
                      {t("light")}
                    </button>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("borderIntensity")}</div>
                  <div className="mt-2 flex items-center gap-2">
                    <input type="range" min="0" max="100"
                      value={Math.round(d.borderIntensity * 100)}
                      onChange={(e) => setD({ borderIntensity: clamp(parseInt(e.target.value, 10) / 100, 0, 1) })}
                      className="w-full" />
                    <div className={["w-12 text-right text-sm font-semibold", themeTokens.textStrong].join(" ")}>
                      {Math.round(d.borderIntensity * 100)}%
                    </div>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("maxDifficulty")}</div>
                      <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>{t("difficultyHint")}</div>
                    </div>
                    <div className={["text-lg font-semibold", themeTokens.textStrong].join(" ")}>
                      {Number(d.maxDifficulty).toFixed(1)}
                    </div>
                  </div>
                  <div className="mt-2">
                    <input type="range" min="1" max="5" step="0.1"
                      value={d.maxDifficulty}
                      onChange={(e) => setD({ maxDifficulty: clamp(parseFloat(e.target.value), 1, 5) })}
                      className="w-full" />
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("roundsPerGame")}</div>
                  <div className="mt-2 flex items-center gap-2">
                    <input type="range" min="5" max="25" value={d.roundsTotal}
                      onChange={(e) => setD({ roundsTotal: parseInt(e.target.value, 10) })}
                      className="w-full" />
                    <div className={["w-10 text-right text-sm font-semibold", themeTokens.textStrong].join(" ")}>
                      {d.roundsTotal}
                    </div>
                  </div>
                </div>

                <div className={["rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("learnLog")}</div>
                      <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>localStorage → CSV export</div>
                    </div>
                  </div>
                  <div className="mt-3 flex gap-2">
                    <button onClick={onDownloadCSV} className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                      {t("downloadCSV")}
                    </button>
                    <button onClick={onResetLog} className={["flex-1 rounded-xl px-3 py-2 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                      {t("resetLog")}
                    </button>
                  </div>
                </div>

              </div>

              <div className="mt-4 flex gap-2">
                <button onClick={() => { setSettings(d); onClose(); }}
                  className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                  {t("save")}
                </button>
                <button onClick={onClose}
                  className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                  {t("close")}
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // -------------------------
    // Globe
    // -------------------------
    function GlobeView({
      countries,
      targetId,
      mode,
      reduceMotion,
      onClickLatLng,
      getFeatureStats,
      theme,
      borderIntensity,
      revealTarget,       // highlight + fly-to when true
      locked,
      clickMarker,
      targetMarker,
      reveal              // <- NEW: needed for distance label
    }) {
      const containerRef = useRef(null);
      const globeRef = useRef(null);
      const gestureRef = useRef({ downX: 0, downY: 0, downT: 0, active: false });

      const globeAssets = useMemo(() => {
        if (theme === "light") {
          return {
            bg: "#eaf2ff",
            atmosphere: "#0ea5e9",
            globeImg: "https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg",
            bumpImg: "https://unpkg.com/three-globe/example/img/earth-topology.png",
          };
        }
        return {
          bg: "#05070b",
          atmosphere: "#67e8f9",
          globeImg: "https://unpkg.com/three-globe/example/img/earth-night.jpg",
          bumpImg: "https://unpkg.com/three-globe/example/img/earth-topology.png",
        };
      }, [theme]);

      const borderStyle = useMemo(() => {
        const I = clamp(borderIntensity ?? 0.8, 0, 1);
        if (theme === "light") {
          return {
            stroke: `rgba(2,6,23,${(0.35 + 0.60 * I).toFixed(3)})`,
            cap: `rgba(2,6,23,${(0.012 + 0.028 * I).toFixed(3)})`,
            capTarget: `rgba(16,185,129,${(0.55 + 0.35 * I).toFixed(3)})`,
            capReveal: `rgba(59,130,246,${(0.60 + 0.30 * I).toFixed(3)})`,
            side: `rgba(0,0,0,0)`
          };
        }
        return {
          stroke: `rgba(226,232,240,${(0.30 + 0.60 * I).toFixed(3)})`,
          cap: `rgba(148,163,184,${(0.015 + 0.030 * I).toFixed(3)})`,
          capTarget: `rgba(16,185,129,${(0.55 + 0.35 * I).toFixed(3)})`,
          capReveal: `rgba(96,165,250,${(0.60 + 0.30 * I).toFixed(3)})`,
          side: `rgba(0,0,0,0)`
        };
      }, [theme, borderIntensity]);

      // Great-circle arc style
      const arcStyle = useMemo(() => {
        if (theme === "light") {
          return {
            color: "rgba(2,6,23,0.85)",
            colorAlt: "rgba(59,130,246,0.95)"
          };
        }
        return {
          color: "rgba(226,232,240,0.85)",
          colorAlt: "rgba(96,165,250,0.95)"
        };
      }, [theme]);

      useEffect(() => {
        const el = containerRef.current;
        if (!el) return;

        const globe = Globe()(el)
          .backgroundColor(globeAssets.bg)
          .showAtmosphere(true)
          .atmosphereColor(globeAssets.atmosphere)
          .atmosphereAltitude(0.14)
          .globeImageUrl(globeAssets.globeImg)
          .bumpImageUrl(globeAssets.bumpImg)
          .enablePointerInteraction(true);

        const controls = globe.controls();
        controls.enableDamping = false;
        controls.rotateSpeed = 0.5;
        controls.zoomSpeed = 0.7;
        controls.minDistance = 180;
        controls.maxDistance = 520;
        controls.enablePan = false;

        try { globe.camera().up.set(0, 1, 0); } catch {}

        const scene = globe.scene();
        scene.add(new THREE.AmbientLight(0xffffff, theme === "light" ? 0.95 : 0.6));
        const dir = new THREE.DirectionalLight(0xffffff, theme === "light" ? 1.1 : 0.9);
        dir.position.set(-100, 200, 300);
        scene.add(dir);

        const ro = new ResizeObserver(() => {
          const { width, height } = el.getBoundingClientRect();
          globe.width(width);
          globe.height(height);
        });
        ro.observe(el);

        const { width, height } = el.getBoundingClientRect();
        globe.width(width);
        globe.height(height);

        globe.pointOfView({ lat: 15, lng: 10, altitude: 2.2 }, 0);
        globeRef.current = globe;

        return () => { try { ro.disconnect(); } catch {} globeRef.current = null; };
      }, []);

      useEffect(() => {
        const globe = globeRef.current;
        if (!globe) return;
        globe.backgroundColor(globeAssets.bg);
        globe.atmosphereColor(globeAssets.atmosphere);
        globe.globeImageUrl(globeAssets.globeImg);
        globe.bumpImageUrl(globeAssets.bumpImg);
      }, [globeAssets]);

      useEffect(() => {
        const globe = globeRef.current;
        if (!globe || !countries?.length) return;

        const baseAlt = 0.014;
        const liftAlt = 0.060;

        globe
          .polygonsData(countries)
          .polygonCapColor(d => {
            if (mode === "choice" && d.id === targetId && !revealTarget) return borderStyle.capTarget;
            if (revealTarget && d.id === targetId) return borderStyle.capReveal;
            return borderStyle.cap;
          })
          .polygonSideColor(() => borderStyle.side)
          .polygonStrokeColor(() => borderStyle.stroke)
          .polygonAltitude(d => {
            if ((mode === "choice" && d.id === targetId && !revealTarget) || (revealTarget && d.id === targetId)) return liftAlt;
            return baseAlt;
          })
          .polygonsTransitionDuration(reduceMotion ? 0 : 250);

        // Points (markers)
        const pts = [];
        if (clickMarker) pts.push({ ...clickMarker, kind: "click" });
        if (targetMarker) pts.push({ ...targetMarker, kind: "target" });

        globe
          .pointsData(pts)
          .pointLat(d => d.lat)
          .pointLng(d => d.lng)
          .pointColor(d => d.kind === "click" ? "rgba(251,113,133,0.9)" : "rgba(34,197,94,0.95)")
          .pointAltitude(d => d.kind === "click" ? 0.02 : 0.03)
          .pointRadius(d => d.kind === "click" ? 0.5 : 0.7);

        // --------
        // NEW: Great-circle learning arc + label (click mode, wrong answer)
        // --------
        const shouldArc = !!(revealTarget &&
          reveal?.mode === "click" &&
          reveal?.correct === false &&
          clickMarker && targetMarker &&
          isFinite(reveal?.distKm));

        const arcs = shouldArc ? [{
          startLat: clickMarker.lat,
          startLng: clickMarker.lng,
          endLat: targetMarker.lat,
          endLng: targetMarker.lng,
          distKm: Math.round(reveal.distKm)
        }] : [];

        globe
          .arcsData(arcs)
          .arcStartLat(d => d.startLat)
          .arcStartLng(d => d.startLng)
          .arcEndLat(d => d.endLat)
          .arcEndLng(d => d.endLng)
          .arcColor(() => [arcStyle.colorAlt, arcStyle.color])
          .arcStroke(() => 0.9)
          .arcAltitude(() => 0.18)
          .arcDashLength(() => 0.45)
          .arcDashGap(() => 0.25)
          .arcDashAnimateTime(() => reduceMotion ? 0 : 1400);

        const labels = shouldArc ? (() => {
          const mid = midPointLatLng(
            { lat: clickMarker.lat, lng: clickMarker.lng },
            { lat: targetMarker.lat, lng: targetMarker.lng }
          );
          return [{
            lat: mid.lat,
            lng: mid.lng,
            text: `${Math.round(reveal.distKm)} km`
          }];
        })() : [];

        globe
          .labelsData(labels)
          .labelLat(d => d.lat)
          .labelLng(d => d.lng)
          .labelText(d => d.text)
          .labelSize(() => 0.9)
          .labelDotRadius(() => 0.0)
          .labelAltitude(() => 0.20)
          .labelColor(() => arcStyle.colorAlt);

      }, [countries, targetId, mode, reduceMotion, borderStyle, revealTarget, clickMarker, targetMarker, reveal, arcStyle]);

      // Click picking
      useEffect(() => {
        const el = containerRef.current;
        const globe = globeRef.current;
        if (!el || !globe) return;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const sphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), 100);

        function pickLatLng(ev) {
          const rect = el.getBoundingClientRect();
          const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -(((ev.clientY - rect.top) / rect.height) * 2 - 1);
          mouse.set(x, y);

          const camera = globe.camera();
          let r = 100;
          try {
            if (typeof globe.getGlobeRadius === "function") r = globe.getGlobeRadius();
            else if (typeof globe.globeRadius === "function") r = globe.globeRadius();
          } catch {}
          sphere.radius = r;

          raycaster.setFromCamera(mouse, camera);
          const hit = new THREE.Vector3();
          const ok = raycaster.ray.intersectSphere(sphere, hit);
          if (!ok) return null;

          const lat = deg(Math.asin(hit.y / r));
          const lng = deg(Math.atan2(hit.x, hit.z));
          return { lat, lng };
        }

        function onPointerDown(ev) {
          if (locked) return;
          if (ev.button != null && ev.button !== 0) return;
          gestureRef.current = { downX: ev.clientX, downY: ev.clientY, downT: performance.now(), active: true };
        }

        function onPointerUp(ev) {
          if (locked) return;
          const g = gestureRef.current;
          if (!g.active) return;
          g.active = false;

          const dx = ev.clientX - g.downX;
          const dy = ev.clientY - g.downY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const dt = performance.now() - g.downT;
          if (dist > 7 || dt > 700) return;

          const pt = pickLatLng(ev);
          if (pt) onClickLatLng?.(pt, ev);
        }

        el.addEventListener("pointerdown", onPointerDown, { passive: true });
        el.addEventListener("pointerup", onPointerUp, { passive: true });
        return () => {
          el.removeEventListener("pointerdown", onPointerDown);
          el.removeEventListener("pointerup", onPointerUp);
        };
      }, [onClickLatLng, locked]);

      // Choice mode fly-to (during question)
      useEffect(() => {
        const globe = globeRef.current;
        if (!globe || !targetId) return;
        if (mode !== "choice") return;
        if (revealTarget) return;

        const st = getFeatureStats?.(targetId);
        if (!st) return;

        const alt = altitudeFromSpan(st.span);
        try { globe.camera().up.set(0, 1, 0); } catch {}
        globe.pointOfView({ lat: st.lat, lng: st.lng, altitude: alt }, reduceMotion ? 0 : 1100);
      }, [targetId, mode, reduceMotion, getFeatureStats, revealTarget]);

      // Reveal fly-to (after answer, both modes)
      useEffect(() => {
        const globe = globeRef.current;
        if (!globe || !targetId) return;
        if (!revealTarget) return;

        const st = getFeatureStats?.(targetId);
        if (!st) return;

        const alt = altitudeFromSpan(st.span);
        try { globe.camera().up.set(0, 1, 0); } catch {}
        globe.pointOfView({ lat: st.lat, lng: st.lng, altitude: alt }, reduceMotion ? 0 : 900);
      }, [revealTarget, targetId, reduceMotion, getFeatureStats]);

      return (
        <div className="relative h-full w-full rounded-2xl overflow-hidden ring-1 ring-black/10">
          <div ref={containerRef} className="absolute inset-0" />
          <div className="pointer-events-none absolute inset-x-0 top-0 p-3">
            <div className="flex items-center justify-between text-xs md:text-sm">
              <span className="inline-flex items-center gap-2 rounded-full bg-black/35 text-white px-3 py-1 ring-1 ring-white/10">
                <span className="h-2 w-2 rounded-full bg-cyan-300/90"></span>
                Drag to rotate · Scroll / pinch to zoom
              </span>
            </div>
          </div>
        </div>
      );
    }

    // -------------------------
    // App
    // -------------------------
    function App() {
      const [loading, setLoading] = useState(true);
      const [loadErr, setLoadErr] = useState("");

      const [settings, setSettings] = useState(() =>
        normalizeSettings(safeLSGet("globeGuess.settings", DEFAULT_SETTINGS))
      );

      useEffect(() => {
        const s = normalizeSettings(settings);
        safeLSSet("globeGuess.settings", s);
        document.body.style.background = s.theme === "light" ? "#f1f5f9" : "#05070b";
      }, [settings]);

      const t = (key) => I18N?.[settings.lang]?.[key] ?? I18N.en[key] ?? key;

      const themeTokens = useMemo(() => {
        if (settings.theme === "light") {
          return {
            page: "bg-slate-100 text-slate-900",
            panel: "bg-white/85",
            card: "bg-white/65",
            ring: "ring-black/10",
            textStrong: "text-slate-900",
            textMuted: "text-slate-700/80",
            btnPrimary: "bg-sky-600/90 hover:bg-sky-600 text-white ring-sky-500/30",
            btnGhost: "bg-white/60 hover:bg-white ring-black/10 text-slate-900",
            btnSelected: "bg-slate-900 text-white ring-black/20",
            btnUnselected: "bg-white/60 hover:bg-white ring-black/10 text-slate-900",
            input: "bg-white/70 text-slate-900"
          };
        }
        return {
          page: "bg-[#05070b] text-slate-100",
          panel: "bg-slate-950/40",
          card: "bg-black/20",
          ring: "ring-white/10",
          textStrong: "text-slate-100",
          textMuted: "text-slate-200/70",
          btnPrimary: "bg-cyan-500/20 hover:bg-cyan-500/30 text-slate-100 ring-cyan-300/20",
          btnGhost: "bg-black/20 hover:bg-white/5 ring-white/10 text-slate-100",
          btnSelected: "bg-white/10 ring-white/20 text-slate-100",
          btnUnselected: "bg-black/20 hover:bg-white/5 ring-white/10 text-slate-100",
          input: "bg-black/30 text-slate-100"
        };
      }, [settings.theme]);

      // Data
      const [countries, setCountries] = useState([]);
      const [idToEN, setIdToEN] = useState(new Map());
      const [idToDE, setIdToDE] = useState(new Map());
      const [diffPack, setDiffPack] = useState(null);

      const activeNames = useMemo(() => settings.lang === "de" ? idToDE : idToEN, [settings.lang, idToDE, idToEN]);

      // Game state
      const [mode, setMode] = useState("click"); // "click" | "choice"
      const [roundIdx, setRoundIdx] = useState(0);
      const [deck, setDeck] = useState([]);
      const [targetId, setTargetId] = useState(null);

      const [score, setScore] = useState(0);
      const [streak, setStreak] = useState(0);
      const [correctCount, setCorrectCount] = useState(0);
      const [wrongCount, setWrongCount] = useState(0);

      const [choices, setChoices] = useState([]);
      const [locked, setLocked] = useState(false);

      // reveal state
      const [reveal, setReveal] = useState(null); // {mode, correct, correctName, yourName, distKm, diff, mult, points}
      const [revealTarget, setRevealTarget] = useState(false);

      const [clickMarker, setClickMarker] = useState(null);
      const [targetMarker, setTargetMarker] = useState(null);

      const [settingsOpen, setSettingsOpen] = useState(false);
      const [gameOverOpen, setGameOverOpen] = useState(false);

      const reduceMotion = useMemo(() => {
        try { return window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches; }
        catch { return false; }
      }, []);

      const [highscores, setHighscores] = useState(() => safeLSGet("globeGuess.highscores", {
        click: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
        choice: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
      }));
      useEffect(() => safeLSSet("globeGuess.highscores", highscores), [highscores]);

      const getFeatureStatsById = useMemo(() => {
        if (!diffPack?.statsById) return null;
        return (id) => diffPack.statsById.get(String(id));
      }, [diffPack]);

      const getDiffById = useMemo(() => {
        if (!diffPack?.diffById) return null;
        return (id) => diffPack.diffById.get(String(id));
      }, [diffPack]);

      const accuracy = useMemo(() => {
        const total = correctCount + wrongCount;
        return total ? correctCount / total : NaN;
      }, [correctCount, wrongCount]);

      // Load local geometry + TSV(id,en,de)
      useEffect(() => {
        (async () => {
          setLoading(true);
          setLoadErr("");
          try {
            const topoRes = await fetch("./data/countries-110m.json", { cache: "no-store" });
            if (!topoRes.ok) throw new Error(`countries-110m.json HTTP ${topoRes.status}`);
            const topo = await topoRes.json();

            const geo = topojson.feature(topo, topo.objects.countries);
            const feats = (geo?.features || []).map(f => ({ ...f, id: String(f.id) }));

            const namesRes = await fetch("./data/country-names.tsv", { cache: "no-store" });
            if (!namesRes.ok) throw new Error(`country-names.tsv HTTP ${namesRes.status}`);
            const tsv = await namesRes.text();

            const mapEN = new Map();
            const mapDE = new Map();

            const lines = tsv.split(/\r?\n/).filter(Boolean);
            const header = lines[0].split("\t").map(s => s.trim().toLowerCase());
            const idIdx = header.indexOf("id");
            const enIdx = header.indexOf("en");
            const deIdx = header.indexOf("de");
            if (idIdx < 0 || enIdx < 0 || deIdx < 0) throw new Error("TSV must have columns: id, en, de");

            for (let i = 1; i < lines.length; i++) {
              const cols = lines[i].split("\t");
              const id = String((cols[idIdx] || "").trim());
              const en = String((cols[enIdx] || "").trim());
              const de = String((cols[deIdx] || "").trim());
              if (id && en) mapEN.set(id, en);
              if (id && de) mapDE.set(id, de);
            }

            const withNames = feats.filter(f => mapEN.has(String(f.id)));
            setCountries(withNames);
            setIdToEN(mapEN);
            setIdToDE(mapDE);

            const pack = computeDifficultyForCountries(withNames, mapEN);
            setDiffPack(pack);

            setLoading(false);
          } catch (e) {
            setLoadErr(String(e?.message || e));
            setLoading(false);
          }
        })();
      }, []);

      function buildDeckForGame() {
        const N = settings.roundsTotal;
        const maxD = settings.maxDifficulty;

        const pool = countries
          .map(f => String(f.id))
          .filter(id => {
            const d = getDiffById?.(id)?.difficulty ?? 3;
            return d <= maxD && idToEN.has(id);
          });

        const safePool = pool.length >= N ? pool : countries.map(f => String(f.id)).filter(id => idToEN.has(id));
        const sorted = safePool.slice().sort((a, b) => (getDiffById?.(a)?.difficulty ?? 3) - (getDiffById?.(b)?.difficulty ?? 3));

        const minD = getDiffById?.(sorted[0])?.difficulty ?? 1;
        const maxAllowed = Math.min(maxD, getDiffById?.(sorted[sorted.length - 1])?.difficulty ?? maxD);

        const remaining = new Set(sorted);
        const out = [];

        for (let i = 0; i < N; i++) {
          let pick;

          if (i === 0) {
            const easySlice = sorted.slice(0, Math.max(25, Math.floor(sorted.length * 0.25)));
            pick = pickCrypto(easySlice);
            remaining.delete(pick);
            out.push(pick);
            continue;
          }

          const alpha = N === 1 ? 1 : (i / (N - 1));
          const targetMax = minD + (maxAllowed - minD) * alpha;

          const cand = [];
          for (const id of remaining) {
            const d = getDiffById?.(id)?.difficulty ?? 3;
            if (d <= targetMax + 1e-6) cand.push(id);
          }

          if (cand.length) {
            cand.sort((a,b)=> (getDiffById?.(a)?.difficulty ?? 3) - (getDiffById?.(b)?.difficulty ?? 3));
            const start = Math.floor(cand.length * 0.55);
            const slice = cand.slice(start);
            pick = pickCrypto(slice.length ? slice : cand);
          } else {
            const remArr = Array.from(remaining);
            remArr.sort((a,b)=> (getDiffById?.(a)?.difficulty ?? 3) - (getDiffById?.(b)?.difficulty ?? 3));
            pick = remArr[0];
          }

          remaining.delete(pick);
          out.push(pick);
        }

        return out;
      }

      function buildChoices(target) {
        const targetIdStr = String(target);
        const pool = countries.map(f => String(f.id)).filter(id => id !== targetIdStr && idToEN.has(id));

        const targetDiff = getDiffById?.(targetIdStr)?.difficulty ?? 3;
        const near = pool
          .map(id => ({ id, d: getDiffById?.(id)?.difficulty ?? 3 }))
          .sort((a,b)=> Math.abs(a.d - targetDiff) - Math.abs(b.d - targetDiff))
          .slice(0, Math.min(100, pool.length))
          .map(x => x.id);

        const distractors = shuffleCrypto(near).slice(0, 7);
        return shuffleCrypto([targetIdStr, ...distractors]).map(id => ({
          id,
          name: activeNames.get(id) || idToEN.get(id) || id,
          correct: id === targetIdStr
        }));
      }

      function resetRoundUI() {
        setReveal(null);
        setRevealTarget(false);
        setLocked(false);
        setClickMarker(null);
        setTargetMarker(null);
      }

      function resetGame(newMode = mode) {
        if (!countries.length || !idToEN.size || !getDiffById) return;

        setMode(newMode);
        setScore(0);
        setStreak(0);
        setCorrectCount(0);
        setWrongCount(0);
        setRoundIdx(0);
        resetRoundUI();
        setGameOverOpen(false);

        const d = buildDeckForGame();
        setDeck(d);
        const first = d[0];
        setTargetId(first);
        if (newMode === "choice") setChoices(buildChoices(first));
        else setChoices([]);
      }

      useEffect(() => {
        if (!loading && !loadErr && countries.length && idToEN.size && getDiffById && deck.length === 0) {
          resetGame("click");
        }
      }, [loading, loadErr, countries.length, idToEN.size, !!getDiffById]);

      useEffect(() => {
        if (!targetId) return;
        if (mode === "choice" && !reveal && choices.length) {
          setChoices(buildChoices(targetId));
        }
      }, [settings.lang]);

      function endGame() {
        const total = correctCount + wrongCount;
        const acc = total ? correctCount / total : 0;
        const hsKey = mode;

        setHighscores(prev => {
          const old = prev[hsKey] || { bestScore: 0, bestAccuracy: 0, bestStreak: 0 };
          return {
            ...prev,
            [hsKey]: {
              bestScore: Math.max(old.bestScore || 0, score),
              bestAccuracy: Math.max(old.bestAccuracy || 0, acc),
              bestStreak: Math.max(old.bestStreak || 0, streak),
            }
          };
        });

        setGameOverOpen(true);
      }

      function gotoNextQuestion() {
        resetRoundUI();

        const nextIdx = roundIdx + 1;
        if (nextIdx >= settings.roundsTotal) {
          endGame();
          return;
        }

        setRoundIdx(nextIdx);
        const nextId = deck[nextIdx];
        setTargetId(nextId);

        if (mode === "choice") setChoices(buildChoices(nextId));
        else setChoices([]);
      }

      useEffect(() => {
        if (!settings.timerEnabled) return;
        if (locked || reveal || gameOverOpen) return;
        if (!targetId) return;

        const ms = settings.secondsPerRound * 1000;
        const timer = setTimeout(() => {
          if (mode === "choice") onChoiceSelect({ id: "__timeout__", name: "⏱️", correct: false }, true);
          else onGlobeClick(null, true);
        }, ms);

        return () => clearTimeout(timer);
      }, [settings.timerEnabled, settings.secondsPerRound, locked, !!reveal, gameOverOpen, targetId, mode]);

      function onGlobeClick(pt, isTimeout = false) {
        if (locked || reveal || mode !== "click") return;
        if (!targetId) return;

        setLocked(true);

        const feature = countries.find(f => String(f.id) === String(targetId));
        const diff = getDiffById?.(targetId)?.difficulty ?? 3;
        const mult = difficultyMultiplier(diff);

        if (!isTimeout && pt) setClickMarker({ lat: pt.lat, lng: pt.lng });

        const st = getFeatureStatsById?.(targetId);
        if (st) setTargetMarker({ lat: st.lat, lng: st.lng });

        const click = (!isTimeout && pt && feature)
          ? polygonDistanceKmToBorder(pt.lng, pt.lat, feature)
          : { inside: false, distKm: 99999 };

        const { base } = baseScoreClick(click.inside, click.distKm);
        const points = Math.round(base * mult);
        const correct = click.inside;

        setScore(s => s + points);
        if (correct) {
          setCorrectCount(c => c + 1);
          setStreak(s => s + 1);
        } else {
          setWrongCount(w => w + 1);
          setStreak(0);
        }

        updateLearnLog(targetId, correct);

        setRevealTarget(true);

        const correctName = activeNames.get(String(targetId)) || idToEN.get(String(targetId)) || "—";
        setReveal({
          mode: "click",
          correct,
          correctName,
          yourName: "",
          distKm: click.distKm,
          diff,
          mult,
          points
        });
      }

      function onChoiceSelect(opt, isTimeout = false) {
        if (locked || reveal || mode !== "choice") return;
        if (!targetId) return;

        setLocked(true);

        const correct = !!opt?.correct;
        const diff = getDiffById?.(targetId)?.difficulty ?? 3;
        const mult = difficultyMultiplier(diff);

        const newStreak = correct ? (streak + 1) : 0;
        const base = baseScoreChoice({ correct, newStreak });
        const points = Math.round(base * mult);

        setScore(s => s + points);
        if (correct) {
          setCorrectCount(c => c + 1);
          setStreak(newStreak);
        } else {
          setWrongCount(w => w + 1);
          setStreak(0);
        }

        updateLearnLog(targetId, correct);

        setRevealTarget(true);

        const correctName = activeNames.get(String(targetId)) || idToEN.get(String(targetId)) || "—";
        setReveal({
          mode: "choice",
          correct,
          correctName,
          yourName: isTimeout ? "⏱️" : (opt?.name || "—"),
          distKm: 0,
          diff,
          mult,
          points
        });
      }

      function setModeAndRestart(m) { resetGame(m); }

      function resetHighscores() {
        setHighscores({
          click: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
          choice: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
        });
      }

      const currentName = targetId ? (activeNames.get(String(targetId)) || idToEN.get(String(targetId)) || "—") : "—";
      const currentDiff = targetId ? (getDiffById?.(targetId)?.difficulty ?? 3) : 3;
      const currentMult = difficultyMultiplier(currentDiff);
      const roundLabel = `${roundIdx + 1}/${settings.roundsTotal}`;

      if (loading) {
        return (
          <div className={["h-full flex items-center justify-center", themeTokens.page].join(" ")}>
            <div className={["rounded-2xl ring-1 p-6", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{t("loading")}</div>
            </div>
          </div>
        );
      }

      if (loadErr) {
        return (
          <div className={["h-full flex items-center justify-center p-4", themeTokens.page].join(" ")}>
            <div className={["max-w-xl w-full rounded-2xl ring-1 p-6", themeTokens.panel, themeTokens.ring].join(" ")}>
              <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{t("loadFailTitle")}</div>
              <div className={["mt-2 text-sm", themeTokens.textMuted].join(" ")}>{t("loadFailTip")}</div>
              <div className={["mt-4 rounded-xl ring-1 p-3 font-mono text-sm whitespace-pre-wrap", themeTokens.card, themeTokens.ring].join(" ")}>
                {loadErr}
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className={["h-full", themeTokens.page].join(" ")}>
          <div className="h-full max-w-7xl mx-auto p-3 sm:p-4 grid grid-cols-1 lg:grid-cols-12 gap-3 sm:gap-4">
            <div className="lg:col-span-7 h-[52vh] lg:h-full">
              <GlobeView
                countries={countries}
                targetId={targetId}
                mode={mode}
                reduceMotion={reduceMotion}
                onClickLatLng={(pt) => onGlobeClick(pt, false)}
                getFeatureStats={(id) => getFeatureStatsById?.(id)}
                theme={settings.theme}
                borderIntensity={settings.borderIntensity}
                revealTarget={revealTarget}
                locked={locked || !!reveal || gameOverOpen}
                clickMarker={clickMarker}
                targetMarker={targetMarker}
                reveal={reveal}
              />
            </div>

            <div className="lg:col-span-5 flex flex-col gap-3 sm:gap-4">
              <div className={["rounded-2xl ring-1 p-4", themeTokens.panel, themeTokens.ring].join(" ")}>
                <div className="flex items-start justify-between gap-3">
                  <div>
                    <div className={["text-3xl font-extrabold leading-tight", themeTokens.textStrong].join(" ")}>{t("title")}</div>
                    <div className={["text-sm mt-1", themeTokens.textMuted].join(" ")}>{t("subtitle")}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 px-3 py-2 text-right", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("round")}</div>
                    <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{roundLabel}</div>
                  </div>
                </div>

                <div className="mt-3 grid grid-cols-4 gap-2">
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("score")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{score}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("streak")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{streak}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("accuracy")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>{fmtPct(accuracy)}</div>
                  </div>
                  <div className={["rounded-2xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                    <div className={["text-[10px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("mode")}</div>
                    <div className={["text-2xl font-bold", themeTokens.textStrong].join(" ")}>
                      {mode === "click" ? t("clickMode") : t("choiceMode")}
                    </div>
                  </div>
                </div>

                <div className={["mt-3 rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className="flex items-center justify-between gap-3">
                    <div>
                      <div className={["text-[11px] uppercase tracking-wide", themeTokens.textMuted].join(" ")}>
                        {t("difficultyClimax")}
                      </div>
                      <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>
                        {t("difficultyClimaxHint")}
                      </div>
                    </div>
                    <div className="text-right">
                      <div className={["text-sm font-bold", themeTokens.textStrong].join(" ")}>
                        {currentDiff.toFixed(2)}/5
                      </div>
                      <div className={["text-xs", themeTokens.textMuted].join(" ")}>{diffStars(currentDiff)}</div>
                      <div className={["text-xs mt-1", themeTokens.textMuted].join(" ")}>
                        {t("difficultyMult")}: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>×{currentMult.toFixed(2)}</span>
                      </div>
                    </div>
                  </div>

                  <div className="mt-4">
                    {mode === "click" ? (
                      <>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("findAndClick")}</div>
                        <div className={["mt-1 text-2xl font-extrabold", themeTokens.textStrong].join(" ")}>
                          {currentName}
                        </div>
                        <div className={["mt-2 text-sm", themeTokens.textMuted].join(" ")}>
                          {t("clickAnywhere")}
                        </div>
                        <div className={["mt-2 text-xs", themeTokens.textMuted].join(" ")}>
                          {t("pointsRuleClick")}
                        </div>
                      </>
                    ) : (
                      <>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("highlightedIs")}</div>
                        <div className={["mt-1 text-xs", themeTokens.textMuted].join(" ")}>{t("highlightHint")}</div>

                        <div className="mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2">
                          {choices.map((opt) => (
                            <button
                              key={`${roundIdx}-${opt.id}`}
                              disabled={locked || !!reveal}
                              onClick={() => onChoiceSelect(opt, false)}
                              className={[
                                "rounded-2xl px-3 py-3 ring-1 transition font-semibold text-sm",
                                (locked || !!reveal) ? "opacity-60 cursor-not-allowed" : "",
                                themeTokens.btnGhost
                              ].join(" ")}
                            >
                              {opt.name}
                            </button>
                          ))}
                        </div>

                        <div className={["mt-2 text-xs", themeTokens.textMuted].join(" ")}>
                          {t("pointsRuleChoice")}
                        </div>
                      </>
                    )}
                  </div>
                </div>

                {/* Inline learning reveal card */}
                {reveal && (
                  <div className={["mt-3 rounded-2xl ring-1 p-4 pop", themeTokens.panel, themeTokens.ring].join(" ")}>
                    <div className="flex items-start justify-between gap-3">
                      <div className={["text-lg font-extrabold", themeTokens.textStrong].join(" ")}>
                        {reveal.correct ? `✅ ${t("correct")}` : `❌ ${t("wrong")}`}
                      </div>
                      <button onClick={() => {
                        // clear arc/label before continuing
                        gotoNextQuestion();
                      }} className={["rounded-xl px-3 py-2 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                        {t("next")}
                      </button>
                    </div>

                    <div className={["mt-3 rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                      <div className="flex items-center justify-between gap-3">
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("correctAnswer")}</div>
                        <div className={["text-sm font-semibold text-right", themeTokens.textStrong].join(" ")}>{reveal.correctName}</div>
                      </div>
                      {reveal.mode === "choice" && (
                        <div className="flex items-center justify-between gap-3 mt-2">
                          <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("yourAnswer")}</div>
                          <div className={["text-sm font-semibold text-right", themeTokens.textStrong].join(" ")}>{reveal.yourName}</div>
                        </div>
                      )}
                      {reveal.mode === "click" && (
                        <div className="flex items-center justify-between gap-3 mt-2">
                          <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("distance")}</div>
                          <div className={["text-sm font-semibold text-right", themeTokens.textStrong].join(" ")}>{Math.round(reveal.distKm)} km</div>
                        </div>
                      )}
                    </div>

                    <div className={["mt-3 rounded-xl ring-1 p-3", themeTokens.card, themeTokens.ring].join(" ")}>
                      <div className="flex items-center justify-between gap-3">
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("difficulty")}</div>
                        <div className={["text-sm font-semibold text-right", themeTokens.textStrong].join(" ")}>
                          {reveal.diff.toFixed(2)}/5 &nbsp; <span className="text-xs">{diffStars(reveal.diff)}</span>
                        </div>
                      </div>
                      <div className="flex items-center justify-between gap-3 mt-2">
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("difficultyMult")}</div>
                        <div className={["text-sm font-semibold text-right", themeTokens.textStrong].join(" ")}>×{reveal.mult.toFixed(2)}</div>
                      </div>
                      <div className="flex items-center justify-between gap-3 mt-2">
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>{t("points")}</div>
                        <div className={["text-sm font-extrabold text-right", themeTokens.textStrong].join(" ")}>
                          {reveal.points >= 0 ? "+" : ""}{reveal.points}
                        </div>
                      </div>
                    </div>

                    {reveal.mode === "click" && !reveal.correct && (
                      <div className={["mt-3 text-xs", themeTokens.textMuted].join(" ")}>
                        Learning aid: the dashed arc shows the shortest path to the correct country; the label shows the distance.
                      </div>
                    )}
                  </div>
                )}

                <div className="mt-3 flex gap-2">
                  <button onClick={() => resetGame(mode)} className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                    {t("newGame")}
                  </button>
                  <button onClick={() => setSettingsOpen(true)} className={["flex-1 rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("settings")}
                  </button>
                  <button onClick={() => setModeAndRestart("click")} className={["rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("clickMode")}
                  </button>
                  <button onClick={() => setModeAndRestart("choice")} className={["rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("choiceMode")}
                  </button>
                </div>
              </div>

              <div className={["rounded-2xl ring-1 p-4", themeTokens.panel, themeTokens.ring].join(" ")}>
                <div className="flex items-center justify-between gap-3">
                  <div className={["text-xl font-bold", themeTokens.textStrong].join(" ")}>{t("highscore")}</div>
                  <button onClick={() => setHighscores({
                    click: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
                    choice: { bestScore: 0, bestAccuracy: 0, bestStreak: 0 },
                  })} className={["rounded-xl px-3 py-2 ring-1 transition text-sm font-semibold", themeTokens.btnGhost].join(" ")}>
                    {t("reset")}
                  </button>
                </div>

                <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {["click","choice"].map(k => {
                    const hs = highscores[k];
                    return (
                      <div key={k} className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                        <div className={["text-sm font-bold", themeTokens.textStrong].join(" ")}>
                          {k === "click" ? t("clickMode") : t("choiceMode")}
                        </div>
                        <div className={["mt-2 text-sm", themeTokens.textMuted].join(" ")}>
                          Best score: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{hs.bestScore}</span>
                        </div>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>
                          Best accuracy: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{fmtPct(hs.bestAccuracy)}</span>
                        </div>
                        <div className={["text-sm", themeTokens.textMuted].join(" ")}>
                          Best streak: <span className={["font-semibold", themeTokens.textStrong].join(" ")}>{hs.bestStreak}</span>
                        </div>
                      </div>
                    );
                  })}
                </div>

                <div className={["mt-3 rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                  <div className={["text-lg font-bold", themeTokens.textStrong].join(" ")}>{t("howTo")}</div>
                  <ul className={["mt-2 text-sm space-y-1 list-disc list-inside", themeTokens.textMuted].join(" ")}>
                    <li>{t("howClick")}</li>
                    <li>{t("howChoice")}</li>
                    <li>{t("howDrag")}</li>
                  </ul>
                </div>
              </div>

              {gameOverOpen && (
                <div className={["rounded-2xl ring-1 p-4 pop", themeTokens.panel, themeTokens.ring].join(" ")}>
                  <div className="flex items-start justify-between gap-3">
                    <div>
                      <div className={["text-2xl font-extrabold", themeTokens.textStrong].join(" ")}>🎉 {t("gameOverTitle")}</div>
                      <div className={["text-sm mt-1", themeTokens.textMuted].join(" ")}>{t("gameOverBody")}</div>
                    </div>
                    <button onClick={() => setGameOverOpen(false)} className={["rounded-xl px-3 py-2 ring-1 transition font-semibold", themeTokens.btnGhost].join(" ")}>
                      {t("close")}
                    </button>
                  </div>

                  <div className="mt-3 grid grid-cols-2 gap-3">
                    <div className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                      <div className={["text-xs uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("score")}</div>
                      <div className={["mt-1 text-3xl font-bold", themeTokens.textStrong].join(" ")}>{score}</div>
                    </div>
                    <div className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                      <div className={["text-xs uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("accuracy")}</div>
                      <div className={["mt-1 text-3xl font-bold", themeTokens.textStrong].join(" ")}>{fmtPct(accuracy)}</div>
                    </div>
                    <div className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                      <div className={["text-xs uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("summaryCorrect")}</div>
                      <div className={["mt-1 text-3xl font-bold", themeTokens.textStrong].join(" ")}>{correctCount}</div>
                    </div>
                    <div className={["rounded-2xl ring-1 p-4", themeTokens.card, themeTokens.ring].join(" ")}>
                      <div className={["text-xs uppercase tracking-wide", themeTokens.textMuted].join(" ")}>{t("summaryWrong")}</div>
                      <div className={["mt-1 text-3xl font-bold", themeTokens.textStrong].join(" ")}>{wrongCount}</div>
                    </div>
                  </div>

                  <div className="mt-4">
                    <button onClick={() => { setGameOverOpen(false); resetGame(mode); }}
                      className={["w-full rounded-xl px-4 py-3 ring-1 transition font-semibold", themeTokens.btnPrimary].join(" ")}>
                      {t("playAgain")}
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>

          <SettingsModal
            open={settingsOpen}
            t={t}
            themeTokens={themeTokens}
            settings={settings}
            setSettings={(s) => {
              const ns = normalizeSettings(s);
              setSettings(ns);
              resetGame(mode);
            }}
            onClose={() => setSettingsOpen(false)}
            onDownloadCSV={() => downloadCSV({ idToEN, idToDE, countries })}
            onResetLog={() => resetLearnLog()}
          />
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
